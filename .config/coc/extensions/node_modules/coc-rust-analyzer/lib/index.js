var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
var __commonJS = (callback, module2) => () => {
  if (!module2) {
    module2 = {exports: {}};
    callback(module2.exports, module2);
  }
  return module2.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {get: all[name], enumerable: true});
};
var __exportStar = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable});
  }
  return target;
};
var __toModule = (module2) => {
  if (module2 && module2.__esModule)
    return module2;
  return __exportStar(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", {value: module2, enumerable: true})), module2);
};

// node_modules/vscode-jsonrpc/lib/is.js
var require_is = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  function boolean(value) {
    return value === true || value === false;
  }
  exports2.boolean = boolean;
  function string(value) {
    return typeof value === "string" || value instanceof String;
  }
  exports2.string = string;
  function number(value) {
    return typeof value === "number" || value instanceof Number;
  }
  exports2.number = number;
  function error(value) {
    return value instanceof Error;
  }
  exports2.error = error;
  function func(value) {
    return typeof value === "function";
  }
  exports2.func = func;
  function array(value) {
    return Array.isArray(value);
  }
  exports2.array = array;
  function stringArray(value) {
    return array(value) && value.every((elem) => string(elem));
  }
  exports2.stringArray = stringArray;
});

// node_modules/vscode-jsonrpc/lib/messages.js
var require_messages = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var is = require_is();
  var ErrorCodes2;
  (function(ErrorCodes3) {
    ErrorCodes3.ParseError = -32700;
    ErrorCodes3.InvalidRequest = -32600;
    ErrorCodes3.MethodNotFound = -32601;
    ErrorCodes3.InvalidParams = -32602;
    ErrorCodes3.InternalError = -32603;
    ErrorCodes3.serverErrorStart = -32099;
    ErrorCodes3.serverErrorEnd = -32e3;
    ErrorCodes3.ServerNotInitialized = -32002;
    ErrorCodes3.UnknownErrorCode = -32001;
    ErrorCodes3.RequestCancelled = -32800;
    ErrorCodes3.ContentModified = -32801;
    ErrorCodes3.MessageWriteError = 1;
    ErrorCodes3.MessageReadError = 2;
  })(ErrorCodes2 = exports2.ErrorCodes || (exports2.ErrorCodes = {}));
  var ResponseError = class extends Error {
    constructor(code, message, data) {
      super(message);
      this.code = is.number(code) ? code : ErrorCodes2.UnknownErrorCode;
      this.data = data;
      Object.setPrototypeOf(this, ResponseError.prototype);
    }
    toJson() {
      return {
        code: this.code,
        message: this.message,
        data: this.data
      };
    }
  };
  exports2.ResponseError = ResponseError;
  var AbstractMessageType = class {
    constructor(_method, _numberOfParams) {
      this._method = _method;
      this._numberOfParams = _numberOfParams;
    }
    get method() {
      return this._method;
    }
    get numberOfParams() {
      return this._numberOfParams;
    }
  };
  exports2.AbstractMessageType = AbstractMessageType;
  var RequestType02 = class extends AbstractMessageType {
    constructor(method) {
      super(method, 0);
    }
  };
  exports2.RequestType0 = RequestType02;
  var RequestType3 = class extends AbstractMessageType {
    constructor(method) {
      super(method, 1);
    }
  };
  exports2.RequestType = RequestType3;
  var RequestType1 = class extends AbstractMessageType {
    constructor(method) {
      super(method, 1);
    }
  };
  exports2.RequestType1 = RequestType1;
  var RequestType22 = class extends AbstractMessageType {
    constructor(method) {
      super(method, 2);
    }
  };
  exports2.RequestType2 = RequestType22;
  var RequestType32 = class extends AbstractMessageType {
    constructor(method) {
      super(method, 3);
    }
  };
  exports2.RequestType3 = RequestType32;
  var RequestType4 = class extends AbstractMessageType {
    constructor(method) {
      super(method, 4);
    }
  };
  exports2.RequestType4 = RequestType4;
  var RequestType5 = class extends AbstractMessageType {
    constructor(method) {
      super(method, 5);
    }
  };
  exports2.RequestType5 = RequestType5;
  var RequestType6 = class extends AbstractMessageType {
    constructor(method) {
      super(method, 6);
    }
  };
  exports2.RequestType6 = RequestType6;
  var RequestType7 = class extends AbstractMessageType {
    constructor(method) {
      super(method, 7);
    }
  };
  exports2.RequestType7 = RequestType7;
  var RequestType8 = class extends AbstractMessageType {
    constructor(method) {
      super(method, 8);
    }
  };
  exports2.RequestType8 = RequestType8;
  var RequestType9 = class extends AbstractMessageType {
    constructor(method) {
      super(method, 9);
    }
  };
  exports2.RequestType9 = RequestType9;
  var NotificationType2 = class extends AbstractMessageType {
    constructor(method) {
      super(method, 1);
      this._ = void 0;
    }
  };
  exports2.NotificationType = NotificationType2;
  var NotificationType0 = class extends AbstractMessageType {
    constructor(method) {
      super(method, 0);
    }
  };
  exports2.NotificationType0 = NotificationType0;
  var NotificationType1 = class extends AbstractMessageType {
    constructor(method) {
      super(method, 1);
    }
  };
  exports2.NotificationType1 = NotificationType1;
  var NotificationType22 = class extends AbstractMessageType {
    constructor(method) {
      super(method, 2);
    }
  };
  exports2.NotificationType2 = NotificationType22;
  var NotificationType3 = class extends AbstractMessageType {
    constructor(method) {
      super(method, 3);
    }
  };
  exports2.NotificationType3 = NotificationType3;
  var NotificationType4 = class extends AbstractMessageType {
    constructor(method) {
      super(method, 4);
    }
  };
  exports2.NotificationType4 = NotificationType4;
  var NotificationType5 = class extends AbstractMessageType {
    constructor(method) {
      super(method, 5);
    }
  };
  exports2.NotificationType5 = NotificationType5;
  var NotificationType6 = class extends AbstractMessageType {
    constructor(method) {
      super(method, 6);
    }
  };
  exports2.NotificationType6 = NotificationType6;
  var NotificationType7 = class extends AbstractMessageType {
    constructor(method) {
      super(method, 7);
    }
  };
  exports2.NotificationType7 = NotificationType7;
  var NotificationType8 = class extends AbstractMessageType {
    constructor(method) {
      super(method, 8);
    }
  };
  exports2.NotificationType8 = NotificationType8;
  var NotificationType9 = class extends AbstractMessageType {
    constructor(method) {
      super(method, 9);
    }
  };
  exports2.NotificationType9 = NotificationType9;
  function isRequestMessage(message) {
    let candidate = message;
    return candidate && is.string(candidate.method) && (is.string(candidate.id) || is.number(candidate.id));
  }
  exports2.isRequestMessage = isRequestMessage;
  function isNotificationMessage(message) {
    let candidate = message;
    return candidate && is.string(candidate.method) && message.id === void 0;
  }
  exports2.isNotificationMessage = isNotificationMessage;
  function isResponseMessage(message) {
    let candidate = message;
    return candidate && (candidate.result !== void 0 || !!candidate.error) && (is.string(candidate.id) || is.number(candidate.id) || candidate.id === null);
  }
  exports2.isResponseMessage = isResponseMessage;
});

// node_modules/vscode-jsonrpc/lib/events.js
var require_events = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var Disposable3;
  (function(Disposable4) {
    function create(func) {
      return {
        dispose: func
      };
    }
    Disposable4.create = create;
  })(Disposable3 = exports2.Disposable || (exports2.Disposable = {}));
  var Event;
  (function(Event2) {
    const _disposable = {dispose() {
    }};
    Event2.None = function() {
      return _disposable;
    };
  })(Event = exports2.Event || (exports2.Event = {}));
  var CallbackList = class {
    add(callback, context = null, bucket) {
      if (!this._callbacks) {
        this._callbacks = [];
        this._contexts = [];
      }
      this._callbacks.push(callback);
      this._contexts.push(context);
      if (Array.isArray(bucket)) {
        bucket.push({dispose: () => this.remove(callback, context)});
      }
    }
    remove(callback, context = null) {
      if (!this._callbacks) {
        return;
      }
      var foundCallbackWithDifferentContext = false;
      for (var i = 0, len = this._callbacks.length; i < len; i++) {
        if (this._callbacks[i] === callback) {
          if (this._contexts[i] === context) {
            this._callbacks.splice(i, 1);
            this._contexts.splice(i, 1);
            return;
          } else {
            foundCallbackWithDifferentContext = true;
          }
        }
      }
      if (foundCallbackWithDifferentContext) {
        throw new Error("When adding a listener with a context, you should remove it with the same context");
      }
    }
    invoke(...args) {
      if (!this._callbacks) {
        return [];
      }
      var ret = [], callbacks = this._callbacks.slice(0), contexts = this._contexts.slice(0);
      for (var i = 0, len = callbacks.length; i < len; i++) {
        try {
          ret.push(callbacks[i].apply(contexts[i], args));
        } catch (e) {
          console.error(e);
        }
      }
      return ret;
    }
    isEmpty() {
      return !this._callbacks || this._callbacks.length === 0;
    }
    dispose() {
      this._callbacks = void 0;
      this._contexts = void 0;
    }
  };
  var Emitter = class {
    constructor(_options) {
      this._options = _options;
    }
    get event() {
      if (!this._event) {
        this._event = (listener, thisArgs, disposables) => {
          if (!this._callbacks) {
            this._callbacks = new CallbackList();
          }
          if (this._options && this._options.onFirstListenerAdd && this._callbacks.isEmpty()) {
            this._options.onFirstListenerAdd(this);
          }
          this._callbacks.add(listener, thisArgs);
          let result;
          result = {
            dispose: () => {
              this._callbacks.remove(listener, thisArgs);
              result.dispose = Emitter._noop;
              if (this._options && this._options.onLastListenerRemove && this._callbacks.isEmpty()) {
                this._options.onLastListenerRemove(this);
              }
            }
          };
          if (Array.isArray(disposables)) {
            disposables.push(result);
          }
          return result;
        };
      }
      return this._event;
    }
    fire(event) {
      if (this._callbacks) {
        this._callbacks.invoke.call(this._callbacks, event);
      }
    }
    dispose() {
      if (this._callbacks) {
        this._callbacks.dispose();
        this._callbacks = void 0;
      }
    }
  };
  exports2.Emitter = Emitter;
  Emitter._noop = function() {
  };
});

// node_modules/vscode-jsonrpc/lib/messageReader.js
var require_messageReader = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var events_1 = require_events();
  var Is = require_is();
  var DefaultSize = 8192;
  var CR = Buffer.from("\r", "ascii")[0];
  var LF = Buffer.from("\n", "ascii")[0];
  var CRLF = "\r\n";
  var MessageBuffer = class {
    constructor(encoding = "utf8") {
      this.encoding = encoding;
      this.index = 0;
      this.buffer = Buffer.allocUnsafe(DefaultSize);
    }
    append(chunk) {
      var toAppend = chunk;
      if (typeof chunk === "string") {
        var str = chunk;
        var bufferLen = Buffer.byteLength(str, this.encoding);
        toAppend = Buffer.allocUnsafe(bufferLen);
        toAppend.write(str, 0, bufferLen, this.encoding);
      }
      if (this.buffer.length - this.index >= toAppend.length) {
        toAppend.copy(this.buffer, this.index, 0, toAppend.length);
      } else {
        var newSize = (Math.ceil((this.index + toAppend.length) / DefaultSize) + 1) * DefaultSize;
        if (this.index === 0) {
          this.buffer = Buffer.allocUnsafe(newSize);
          toAppend.copy(this.buffer, 0, 0, toAppend.length);
        } else {
          this.buffer = Buffer.concat([this.buffer.slice(0, this.index), toAppend], newSize);
        }
      }
      this.index += toAppend.length;
    }
    tryReadHeaders() {
      let result = void 0;
      let current = 0;
      while (current + 3 < this.index && (this.buffer[current] !== CR || this.buffer[current + 1] !== LF || this.buffer[current + 2] !== CR || this.buffer[current + 3] !== LF)) {
        current++;
      }
      if (current + 3 >= this.index) {
        return result;
      }
      result = Object.create(null);
      let headers = this.buffer.toString("ascii", 0, current).split(CRLF);
      headers.forEach((header) => {
        let index = header.indexOf(":");
        if (index === -1) {
          throw new Error("Message header must separate key and value using :");
        }
        let key = header.substr(0, index);
        let value = header.substr(index + 1).trim();
        result[key] = value;
      });
      let nextStart = current + 4;
      this.buffer = this.buffer.slice(nextStart);
      this.index = this.index - nextStart;
      return result;
    }
    tryReadContent(length) {
      if (this.index < length) {
        return null;
      }
      let result = this.buffer.toString(this.encoding, 0, length);
      let nextStart = length;
      this.buffer.copy(this.buffer, 0, nextStart);
      this.index = this.index - nextStart;
      return result;
    }
    get numberOfBytes() {
      return this.index;
    }
  };
  var MessageReader;
  (function(MessageReader2) {
    function is(value) {
      let candidate = value;
      return candidate && Is.func(candidate.listen) && Is.func(candidate.dispose) && Is.func(candidate.onError) && Is.func(candidate.onClose) && Is.func(candidate.onPartialMessage);
    }
    MessageReader2.is = is;
  })(MessageReader = exports2.MessageReader || (exports2.MessageReader = {}));
  var AbstractMessageReader = class {
    constructor() {
      this.errorEmitter = new events_1.Emitter();
      this.closeEmitter = new events_1.Emitter();
      this.partialMessageEmitter = new events_1.Emitter();
    }
    dispose() {
      this.errorEmitter.dispose();
      this.closeEmitter.dispose();
    }
    get onError() {
      return this.errorEmitter.event;
    }
    fireError(error) {
      this.errorEmitter.fire(this.asError(error));
    }
    get onClose() {
      return this.closeEmitter.event;
    }
    fireClose() {
      this.closeEmitter.fire(void 0);
    }
    get onPartialMessage() {
      return this.partialMessageEmitter.event;
    }
    firePartialMessage(info) {
      this.partialMessageEmitter.fire(info);
    }
    asError(error) {
      if (error instanceof Error) {
        return error;
      } else {
        return new Error(`Reader received error. Reason: ${Is.string(error.message) ? error.message : "unknown"}`);
      }
    }
  };
  exports2.AbstractMessageReader = AbstractMessageReader;
  var StreamMessageReader = class extends AbstractMessageReader {
    constructor(readable, encoding = "utf8") {
      super();
      this.readable = readable;
      this.buffer = new MessageBuffer(encoding);
      this._partialMessageTimeout = 1e4;
    }
    set partialMessageTimeout(timeout) {
      this._partialMessageTimeout = timeout;
    }
    get partialMessageTimeout() {
      return this._partialMessageTimeout;
    }
    listen(callback) {
      this.nextMessageLength = -1;
      this.messageToken = 0;
      this.partialMessageTimer = void 0;
      this.callback = callback;
      this.readable.on("data", (data) => {
        this.onData(data);
      });
      this.readable.on("error", (error) => this.fireError(error));
      this.readable.on("close", () => this.fireClose());
    }
    onData(data) {
      this.buffer.append(data);
      while (true) {
        if (this.nextMessageLength === -1) {
          let headers = this.buffer.tryReadHeaders();
          if (!headers) {
            return;
          }
          let contentLength = headers["Content-Length"];
          if (!contentLength) {
            throw new Error("Header must provide a Content-Length property.");
          }
          let length = parseInt(contentLength);
          if (isNaN(length)) {
            throw new Error("Content-Length value must be a number.");
          }
          this.nextMessageLength = length;
        }
        var msg = this.buffer.tryReadContent(this.nextMessageLength);
        if (msg === null) {
          this.setPartialMessageTimer();
          return;
        }
        this.clearPartialMessageTimer();
        this.nextMessageLength = -1;
        this.messageToken++;
        var json = JSON.parse(msg);
        this.callback(json);
      }
    }
    clearPartialMessageTimer() {
      if (this.partialMessageTimer) {
        clearTimeout(this.partialMessageTimer);
        this.partialMessageTimer = void 0;
      }
    }
    setPartialMessageTimer() {
      this.clearPartialMessageTimer();
      if (this._partialMessageTimeout <= 0) {
        return;
      }
      this.partialMessageTimer = setTimeout((token, timeout) => {
        this.partialMessageTimer = void 0;
        if (token === this.messageToken) {
          this.firePartialMessage({messageToken: token, waitingTime: timeout});
          this.setPartialMessageTimer();
        }
      }, this._partialMessageTimeout, this.messageToken, this._partialMessageTimeout);
    }
  };
  exports2.StreamMessageReader = StreamMessageReader;
  var IPCMessageReader = class extends AbstractMessageReader {
    constructor(process2) {
      super();
      this.process = process2;
      let eventEmitter = this.process;
      eventEmitter.on("error", (error) => this.fireError(error));
      eventEmitter.on("close", () => this.fireClose());
    }
    listen(callback) {
      this.process.on("message", callback);
    }
  };
  exports2.IPCMessageReader = IPCMessageReader;
  var SocketMessageReader = class extends StreamMessageReader {
    constructor(socket, encoding = "utf-8") {
      super(socket, encoding);
    }
  };
  exports2.SocketMessageReader = SocketMessageReader;
});

// node_modules/vscode-jsonrpc/lib/messageWriter.js
var require_messageWriter = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var events_1 = require_events();
  var Is = require_is();
  var ContentLength = "Content-Length: ";
  var CRLF = "\r\n";
  var MessageWriter;
  (function(MessageWriter2) {
    function is(value) {
      let candidate = value;
      return candidate && Is.func(candidate.dispose) && Is.func(candidate.onClose) && Is.func(candidate.onError) && Is.func(candidate.write);
    }
    MessageWriter2.is = is;
  })(MessageWriter = exports2.MessageWriter || (exports2.MessageWriter = {}));
  var AbstractMessageWriter = class {
    constructor() {
      this.errorEmitter = new events_1.Emitter();
      this.closeEmitter = new events_1.Emitter();
    }
    dispose() {
      this.errorEmitter.dispose();
      this.closeEmitter.dispose();
    }
    get onError() {
      return this.errorEmitter.event;
    }
    fireError(error, message, count) {
      this.errorEmitter.fire([this.asError(error), message, count]);
    }
    get onClose() {
      return this.closeEmitter.event;
    }
    fireClose() {
      this.closeEmitter.fire(void 0);
    }
    asError(error) {
      if (error instanceof Error) {
        return error;
      } else {
        return new Error(`Writer received error. Reason: ${Is.string(error.message) ? error.message : "unknown"}`);
      }
    }
  };
  exports2.AbstractMessageWriter = AbstractMessageWriter;
  var StreamMessageWriter = class extends AbstractMessageWriter {
    constructor(writable, encoding = "utf8") {
      super();
      this.writable = writable;
      this.encoding = encoding;
      this.errorCount = 0;
      this.writable.on("error", (error) => this.fireError(error));
      this.writable.on("close", () => this.fireClose());
    }
    write(msg) {
      let json = JSON.stringify(msg);
      let contentLength = Buffer.byteLength(json, this.encoding);
      let headers = [
        ContentLength,
        contentLength.toString(),
        CRLF,
        CRLF
      ];
      try {
        this.writable.write(headers.join(""), "ascii");
        this.writable.write(json, this.encoding);
        this.errorCount = 0;
      } catch (error) {
        this.errorCount++;
        this.fireError(error, msg, this.errorCount);
      }
    }
  };
  exports2.StreamMessageWriter = StreamMessageWriter;
  var IPCMessageWriter = class extends AbstractMessageWriter {
    constructor(process2) {
      super();
      this.process = process2;
      this.errorCount = 0;
      this.queue = [];
      this.sending = false;
      let eventEmitter = this.process;
      eventEmitter.on("error", (error) => this.fireError(error));
      eventEmitter.on("close", () => this.fireClose);
    }
    write(msg) {
      if (!this.sending && this.queue.length === 0) {
        this.doWriteMessage(msg);
      } else {
        this.queue.push(msg);
      }
    }
    doWriteMessage(msg) {
      try {
        if (this.process.send) {
          this.sending = true;
          this.process.send(msg, void 0, void 0, (error) => {
            this.sending = false;
            if (error) {
              this.errorCount++;
              this.fireError(error, msg, this.errorCount);
            } else {
              this.errorCount = 0;
            }
            if (this.queue.length > 0) {
              this.doWriteMessage(this.queue.shift());
            }
          });
        }
      } catch (error) {
        this.errorCount++;
        this.fireError(error, msg, this.errorCount);
      }
    }
  };
  exports2.IPCMessageWriter = IPCMessageWriter;
  var SocketMessageWriter = class extends AbstractMessageWriter {
    constructor(socket, encoding = "utf8") {
      super();
      this.socket = socket;
      this.queue = [];
      this.sending = false;
      this.encoding = encoding;
      this.errorCount = 0;
      this.socket.on("error", (error) => this.fireError(error));
      this.socket.on("close", () => this.fireClose());
    }
    dispose() {
      super.dispose();
      this.socket.destroy();
    }
    write(msg) {
      if (!this.sending && this.queue.length === 0) {
        this.doWriteMessage(msg);
      } else {
        this.queue.push(msg);
      }
    }
    doWriteMessage(msg) {
      let json = JSON.stringify(msg);
      let contentLength = Buffer.byteLength(json, this.encoding);
      let headers = [
        ContentLength,
        contentLength.toString(),
        CRLF,
        CRLF
      ];
      try {
        this.sending = true;
        this.socket.write(headers.join(""), "ascii", (error) => {
          if (error) {
            this.handleError(error, msg);
          }
          try {
            this.socket.write(json, this.encoding, (error2) => {
              this.sending = false;
              if (error2) {
                this.handleError(error2, msg);
              } else {
                this.errorCount = 0;
              }
              if (this.queue.length > 0) {
                this.doWriteMessage(this.queue.shift());
              }
            });
          } catch (error2) {
            this.handleError(error2, msg);
          }
        });
      } catch (error) {
        this.handleError(error, msg);
      }
    }
    handleError(error, msg) {
      this.errorCount++;
      this.fireError(error, msg, this.errorCount);
    }
  };
  exports2.SocketMessageWriter = SocketMessageWriter;
});

// node_modules/vscode-jsonrpc/lib/cancellation.js
var require_cancellation = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var events_1 = require_events();
  var Is = require_is();
  var CancellationToken2;
  (function(CancellationToken3) {
    CancellationToken3.None = Object.freeze({
      isCancellationRequested: false,
      onCancellationRequested: events_1.Event.None
    });
    CancellationToken3.Cancelled = Object.freeze({
      isCancellationRequested: true,
      onCancellationRequested: events_1.Event.None
    });
    function is(value) {
      let candidate = value;
      return candidate && (candidate === CancellationToken3.None || candidate === CancellationToken3.Cancelled || Is.boolean(candidate.isCancellationRequested) && !!candidate.onCancellationRequested);
    }
    CancellationToken3.is = is;
  })(CancellationToken2 = exports2.CancellationToken || (exports2.CancellationToken = {}));
  var shortcutEvent = Object.freeze(function(callback, context) {
    let handle = setTimeout(callback.bind(context), 0);
    return {dispose() {
      clearTimeout(handle);
    }};
  });
  var MutableToken = class {
    constructor() {
      this._isCancelled = false;
    }
    cancel() {
      if (!this._isCancelled) {
        this._isCancelled = true;
        if (this._emitter) {
          this._emitter.fire(void 0);
          this.dispose();
        }
      }
    }
    get isCancellationRequested() {
      return this._isCancelled;
    }
    get onCancellationRequested() {
      if (this._isCancelled) {
        return shortcutEvent;
      }
      if (!this._emitter) {
        this._emitter = new events_1.Emitter();
      }
      return this._emitter.event;
    }
    dispose() {
      if (this._emitter) {
        this._emitter.dispose();
        this._emitter = void 0;
      }
    }
  };
  var CancellationTokenSource2 = class {
    get token() {
      if (!this._token) {
        this._token = new MutableToken();
      }
      return this._token;
    }
    cancel() {
      if (!this._token) {
        this._token = CancellationToken2.Cancelled;
      } else {
        this._token.cancel();
      }
    }
    dispose() {
      if (!this._token) {
        this._token = CancellationToken2.None;
      } else if (this._token instanceof MutableToken) {
        this._token.dispose();
      }
    }
  };
  exports2.CancellationTokenSource = CancellationTokenSource2;
});

// node_modules/vscode-jsonrpc/lib/linkedMap.js
var require_linkedMap = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var Touch;
  (function(Touch2) {
    Touch2.None = 0;
    Touch2.First = 1;
    Touch2.Last = 2;
  })(Touch = exports2.Touch || (exports2.Touch = {}));
  var LinkedMap = class {
    constructor() {
      this._map = new Map();
      this._head = void 0;
      this._tail = void 0;
      this._size = 0;
    }
    clear() {
      this._map.clear();
      this._head = void 0;
      this._tail = void 0;
      this._size = 0;
    }
    isEmpty() {
      return !this._head && !this._tail;
    }
    get size() {
      return this._size;
    }
    has(key) {
      return this._map.has(key);
    }
    get(key) {
      const item = this._map.get(key);
      if (!item) {
        return void 0;
      }
      return item.value;
    }
    set(key, value, touch = Touch.None) {
      let item = this._map.get(key);
      if (item) {
        item.value = value;
        if (touch !== Touch.None) {
          this.touch(item, touch);
        }
      } else {
        item = {key, value, next: void 0, previous: void 0};
        switch (touch) {
          case Touch.None:
            this.addItemLast(item);
            break;
          case Touch.First:
            this.addItemFirst(item);
            break;
          case Touch.Last:
            this.addItemLast(item);
            break;
          default:
            this.addItemLast(item);
            break;
        }
        this._map.set(key, item);
        this._size++;
      }
    }
    delete(key) {
      const item = this._map.get(key);
      if (!item) {
        return false;
      }
      this._map.delete(key);
      this.removeItem(item);
      this._size--;
      return true;
    }
    shift() {
      if (!this._head && !this._tail) {
        return void 0;
      }
      if (!this._head || !this._tail) {
        throw new Error("Invalid list");
      }
      const item = this._head;
      this._map.delete(item.key);
      this.removeItem(item);
      this._size--;
      return item.value;
    }
    forEach(callbackfn, thisArg) {
      let current = this._head;
      while (current) {
        if (thisArg) {
          callbackfn.bind(thisArg)(current.value, current.key, this);
        } else {
          callbackfn(current.value, current.key, this);
        }
        current = current.next;
      }
    }
    forEachReverse(callbackfn, thisArg) {
      let current = this._tail;
      while (current) {
        if (thisArg) {
          callbackfn.bind(thisArg)(current.value, current.key, this);
        } else {
          callbackfn(current.value, current.key, this);
        }
        current = current.previous;
      }
    }
    values() {
      let result = [];
      let current = this._head;
      while (current) {
        result.push(current.value);
        current = current.next;
      }
      return result;
    }
    keys() {
      let result = [];
      let current = this._head;
      while (current) {
        result.push(current.key);
        current = current.next;
      }
      return result;
    }
    addItemFirst(item) {
      if (!this._head && !this._tail) {
        this._tail = item;
      } else if (!this._head) {
        throw new Error("Invalid list");
      } else {
        item.next = this._head;
        this._head.previous = item;
      }
      this._head = item;
    }
    addItemLast(item) {
      if (!this._head && !this._tail) {
        this._head = item;
      } else if (!this._tail) {
        throw new Error("Invalid list");
      } else {
        item.previous = this._tail;
        this._tail.next = item;
      }
      this._tail = item;
    }
    removeItem(item) {
      if (item === this._head && item === this._tail) {
        this._head = void 0;
        this._tail = void 0;
      } else if (item === this._head) {
        this._head = item.next;
      } else if (item === this._tail) {
        this._tail = item.previous;
      } else {
        const next = item.next;
        const previous = item.previous;
        if (!next || !previous) {
          throw new Error("Invalid list");
        }
        next.previous = previous;
        previous.next = next;
      }
    }
    touch(item, touch) {
      if (!this._head || !this._tail) {
        throw new Error("Invalid list");
      }
      if (touch !== Touch.First && touch !== Touch.Last) {
        return;
      }
      if (touch === Touch.First) {
        if (item === this._head) {
          return;
        }
        const next = item.next;
        const previous = item.previous;
        if (item === this._tail) {
          previous.next = void 0;
          this._tail = previous;
        } else {
          next.previous = previous;
          previous.next = next;
        }
        item.previous = void 0;
        item.next = this._head;
        this._head.previous = item;
        this._head = item;
      } else if (touch === Touch.Last) {
        if (item === this._tail) {
          return;
        }
        const next = item.next;
        const previous = item.previous;
        if (item === this._head) {
          next.previous = void 0;
          this._head = next;
        } else {
          next.previous = previous;
          previous.next = next;
        }
        item.next = void 0;
        item.previous = this._tail;
        this._tail.next = item;
        this._tail = item;
      }
    }
  };
  exports2.LinkedMap = LinkedMap;
});

// node_modules/vscode-jsonrpc/lib/pipeSupport.js
var require_pipeSupport = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var path_1 = require("path");
  var os_1 = require("os");
  var crypto_1 = require("crypto");
  var net_1 = require("net");
  var messageReader_1 = require_messageReader();
  var messageWriter_1 = require_messageWriter();
  function generateRandomPipeName() {
    const randomSuffix = crypto_1.randomBytes(21).toString("hex");
    if (process.platform === "win32") {
      return `\\\\.\\pipe\\vscode-jsonrpc-${randomSuffix}-sock`;
    } else {
      return path_1.join(os_1.tmpdir(), `vscode-${randomSuffix}.sock`);
    }
  }
  exports2.generateRandomPipeName = generateRandomPipeName;
  function createClientPipeTransport(pipeName, encoding = "utf-8") {
    let connectResolve;
    let connected = new Promise((resolve, _reject) => {
      connectResolve = resolve;
    });
    return new Promise((resolve, reject) => {
      let server = net_1.createServer((socket) => {
        server.close();
        connectResolve([
          new messageReader_1.SocketMessageReader(socket, encoding),
          new messageWriter_1.SocketMessageWriter(socket, encoding)
        ]);
      });
      server.on("error", reject);
      server.listen(pipeName, () => {
        server.removeListener("error", reject);
        resolve({
          onConnected: () => {
            return connected;
          }
        });
      });
    });
  }
  exports2.createClientPipeTransport = createClientPipeTransport;
  function createServerPipeTransport(pipeName, encoding = "utf-8") {
    const socket = net_1.createConnection(pipeName);
    return [
      new messageReader_1.SocketMessageReader(socket, encoding),
      new messageWriter_1.SocketMessageWriter(socket, encoding)
    ];
  }
  exports2.createServerPipeTransport = createServerPipeTransport;
});

// node_modules/vscode-jsonrpc/lib/socketSupport.js
var require_socketSupport = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var net_1 = require("net");
  var messageReader_1 = require_messageReader();
  var messageWriter_1 = require_messageWriter();
  function createClientSocketTransport(port, encoding = "utf-8") {
    let connectResolve;
    let connected = new Promise((resolve, _reject) => {
      connectResolve = resolve;
    });
    return new Promise((resolve, reject) => {
      let server = net_1.createServer((socket) => {
        server.close();
        connectResolve([
          new messageReader_1.SocketMessageReader(socket, encoding),
          new messageWriter_1.SocketMessageWriter(socket, encoding)
        ]);
      });
      server.on("error", reject);
      server.listen(port, "127.0.0.1", () => {
        server.removeListener("error", reject);
        resolve({
          onConnected: () => {
            return connected;
          }
        });
      });
    });
  }
  exports2.createClientSocketTransport = createClientSocketTransport;
  function createServerSocketTransport(port, encoding = "utf-8") {
    const socket = net_1.createConnection(port, "127.0.0.1");
    return [
      new messageReader_1.SocketMessageReader(socket, encoding),
      new messageWriter_1.SocketMessageWriter(socket, encoding)
    ];
  }
  exports2.createServerSocketTransport = createServerSocketTransport;
});

// node_modules/vscode-jsonrpc/lib/main.js
var require_main = __commonJS((exports2) => {
  "use strict";
  function __export2(m) {
    for (var p in m)
      if (!exports2.hasOwnProperty(p))
        exports2[p] = m[p];
  }
  Object.defineProperty(exports2, "__esModule", {value: true});
  var Is = require_is();
  var messages_1 = require_messages();
  exports2.RequestType = messages_1.RequestType;
  exports2.RequestType0 = messages_1.RequestType0;
  exports2.RequestType1 = messages_1.RequestType1;
  exports2.RequestType2 = messages_1.RequestType2;
  exports2.RequestType3 = messages_1.RequestType3;
  exports2.RequestType4 = messages_1.RequestType4;
  exports2.RequestType5 = messages_1.RequestType5;
  exports2.RequestType6 = messages_1.RequestType6;
  exports2.RequestType7 = messages_1.RequestType7;
  exports2.RequestType8 = messages_1.RequestType8;
  exports2.RequestType9 = messages_1.RequestType9;
  exports2.ResponseError = messages_1.ResponseError;
  exports2.ErrorCodes = messages_1.ErrorCodes;
  exports2.NotificationType = messages_1.NotificationType;
  exports2.NotificationType0 = messages_1.NotificationType0;
  exports2.NotificationType1 = messages_1.NotificationType1;
  exports2.NotificationType2 = messages_1.NotificationType2;
  exports2.NotificationType3 = messages_1.NotificationType3;
  exports2.NotificationType4 = messages_1.NotificationType4;
  exports2.NotificationType5 = messages_1.NotificationType5;
  exports2.NotificationType6 = messages_1.NotificationType6;
  exports2.NotificationType7 = messages_1.NotificationType7;
  exports2.NotificationType8 = messages_1.NotificationType8;
  exports2.NotificationType9 = messages_1.NotificationType9;
  var messageReader_1 = require_messageReader();
  exports2.MessageReader = messageReader_1.MessageReader;
  exports2.StreamMessageReader = messageReader_1.StreamMessageReader;
  exports2.IPCMessageReader = messageReader_1.IPCMessageReader;
  exports2.SocketMessageReader = messageReader_1.SocketMessageReader;
  var messageWriter_1 = require_messageWriter();
  exports2.MessageWriter = messageWriter_1.MessageWriter;
  exports2.StreamMessageWriter = messageWriter_1.StreamMessageWriter;
  exports2.IPCMessageWriter = messageWriter_1.IPCMessageWriter;
  exports2.SocketMessageWriter = messageWriter_1.SocketMessageWriter;
  var events_1 = require_events();
  exports2.Disposable = events_1.Disposable;
  exports2.Event = events_1.Event;
  exports2.Emitter = events_1.Emitter;
  var cancellation_1 = require_cancellation();
  exports2.CancellationTokenSource = cancellation_1.CancellationTokenSource;
  exports2.CancellationToken = cancellation_1.CancellationToken;
  var linkedMap_1 = require_linkedMap();
  __export2(require_pipeSupport());
  __export2(require_socketSupport());
  var CancelNotification;
  (function(CancelNotification2) {
    CancelNotification2.type = new messages_1.NotificationType("$/cancelRequest");
  })(CancelNotification || (CancelNotification = {}));
  var ProgressNotification;
  (function(ProgressNotification2) {
    ProgressNotification2.type = new messages_1.NotificationType("$/progress");
  })(ProgressNotification || (ProgressNotification = {}));
  var ProgressType = class {
    constructor() {
    }
  };
  exports2.ProgressType = ProgressType;
  exports2.NullLogger = Object.freeze({
    error: () => {
    },
    warn: () => {
    },
    info: () => {
    },
    log: () => {
    }
  });
  var Trace;
  (function(Trace2) {
    Trace2[Trace2["Off"] = 0] = "Off";
    Trace2[Trace2["Messages"] = 1] = "Messages";
    Trace2[Trace2["Verbose"] = 2] = "Verbose";
  })(Trace = exports2.Trace || (exports2.Trace = {}));
  (function(Trace2) {
    function fromString(value) {
      if (!Is.string(value)) {
        return Trace2.Off;
      }
      value = value.toLowerCase();
      switch (value) {
        case "off":
          return Trace2.Off;
        case "messages":
          return Trace2.Messages;
        case "verbose":
          return Trace2.Verbose;
        default:
          return Trace2.Off;
      }
    }
    Trace2.fromString = fromString;
    function toString(value) {
      switch (value) {
        case Trace2.Off:
          return "off";
        case Trace2.Messages:
          return "messages";
        case Trace2.Verbose:
          return "verbose";
        default:
          return "off";
      }
    }
    Trace2.toString = toString;
  })(Trace = exports2.Trace || (exports2.Trace = {}));
  var TraceFormat;
  (function(TraceFormat2) {
    TraceFormat2["Text"] = "text";
    TraceFormat2["JSON"] = "json";
  })(TraceFormat = exports2.TraceFormat || (exports2.TraceFormat = {}));
  (function(TraceFormat2) {
    function fromString(value) {
      value = value.toLowerCase();
      if (value === "json") {
        return TraceFormat2.JSON;
      } else {
        return TraceFormat2.Text;
      }
    }
    TraceFormat2.fromString = fromString;
  })(TraceFormat = exports2.TraceFormat || (exports2.TraceFormat = {}));
  var SetTraceNotification;
  (function(SetTraceNotification2) {
    SetTraceNotification2.type = new messages_1.NotificationType("$/setTraceNotification");
  })(SetTraceNotification = exports2.SetTraceNotification || (exports2.SetTraceNotification = {}));
  var LogTraceNotification;
  (function(LogTraceNotification2) {
    LogTraceNotification2.type = new messages_1.NotificationType("$/logTraceNotification");
  })(LogTraceNotification = exports2.LogTraceNotification || (exports2.LogTraceNotification = {}));
  var ConnectionErrors;
  (function(ConnectionErrors2) {
    ConnectionErrors2[ConnectionErrors2["Closed"] = 1] = "Closed";
    ConnectionErrors2[ConnectionErrors2["Disposed"] = 2] = "Disposed";
    ConnectionErrors2[ConnectionErrors2["AlreadyListening"] = 3] = "AlreadyListening";
  })(ConnectionErrors = exports2.ConnectionErrors || (exports2.ConnectionErrors = {}));
  var ConnectionError = class extends Error {
    constructor(code, message) {
      super(message);
      this.code = code;
      Object.setPrototypeOf(this, ConnectionError.prototype);
    }
  };
  exports2.ConnectionError = ConnectionError;
  var ConnectionStrategy;
  (function(ConnectionStrategy2) {
    function is(value) {
      let candidate = value;
      return candidate && Is.func(candidate.cancelUndispatched);
    }
    ConnectionStrategy2.is = is;
  })(ConnectionStrategy = exports2.ConnectionStrategy || (exports2.ConnectionStrategy = {}));
  var ConnectionState;
  (function(ConnectionState2) {
    ConnectionState2[ConnectionState2["New"] = 1] = "New";
    ConnectionState2[ConnectionState2["Listening"] = 2] = "Listening";
    ConnectionState2[ConnectionState2["Closed"] = 3] = "Closed";
    ConnectionState2[ConnectionState2["Disposed"] = 4] = "Disposed";
  })(ConnectionState || (ConnectionState = {}));
  function _createMessageConnection(messageReader, messageWriter, logger, strategy) {
    let sequenceNumber = 0;
    let notificationSquenceNumber = 0;
    let unknownResponseSquenceNumber = 0;
    const version = "2.0";
    let starRequestHandler = void 0;
    let requestHandlers = Object.create(null);
    let starNotificationHandler = void 0;
    let notificationHandlers = Object.create(null);
    let progressHandlers = new Map();
    let timer;
    let messageQueue = new linkedMap_1.LinkedMap();
    let responsePromises = Object.create(null);
    let requestTokens = Object.create(null);
    let trace = Trace.Off;
    let traceFormat = TraceFormat.Text;
    let tracer;
    let state = ConnectionState.New;
    let errorEmitter = new events_1.Emitter();
    let closeEmitter = new events_1.Emitter();
    let unhandledNotificationEmitter = new events_1.Emitter();
    let unhandledProgressEmitter = new events_1.Emitter();
    let disposeEmitter = new events_1.Emitter();
    function createRequestQueueKey(id) {
      return "req-" + id.toString();
    }
    function createResponseQueueKey(id) {
      if (id === null) {
        return "res-unknown-" + (++unknownResponseSquenceNumber).toString();
      } else {
        return "res-" + id.toString();
      }
    }
    function createNotificationQueueKey() {
      return "not-" + (++notificationSquenceNumber).toString();
    }
    function addMessageToQueue(queue, message) {
      if (messages_1.isRequestMessage(message)) {
        queue.set(createRequestQueueKey(message.id), message);
      } else if (messages_1.isResponseMessage(message)) {
        queue.set(createResponseQueueKey(message.id), message);
      } else {
        queue.set(createNotificationQueueKey(), message);
      }
    }
    function cancelUndispatched(_message) {
      return void 0;
    }
    function isListening() {
      return state === ConnectionState.Listening;
    }
    function isClosed() {
      return state === ConnectionState.Closed;
    }
    function isDisposed() {
      return state === ConnectionState.Disposed;
    }
    function closeHandler() {
      if (state === ConnectionState.New || state === ConnectionState.Listening) {
        state = ConnectionState.Closed;
        closeEmitter.fire(void 0);
      }
    }
    function readErrorHandler(error) {
      errorEmitter.fire([error, void 0, void 0]);
    }
    function writeErrorHandler(data) {
      errorEmitter.fire(data);
    }
    messageReader.onClose(closeHandler);
    messageReader.onError(readErrorHandler);
    messageWriter.onClose(closeHandler);
    messageWriter.onError(writeErrorHandler);
    function triggerMessageQueue() {
      if (timer || messageQueue.size === 0) {
        return;
      }
      timer = setImmediate(() => {
        timer = void 0;
        processMessageQueue();
      });
    }
    function processMessageQueue() {
      if (messageQueue.size === 0) {
        return;
      }
      let message = messageQueue.shift();
      try {
        if (messages_1.isRequestMessage(message)) {
          handleRequest(message);
        } else if (messages_1.isNotificationMessage(message)) {
          handleNotification(message);
        } else if (messages_1.isResponseMessage(message)) {
          handleResponse(message);
        } else {
          handleInvalidMessage(message);
        }
      } finally {
        triggerMessageQueue();
      }
    }
    let callback = (message) => {
      try {
        if (messages_1.isNotificationMessage(message) && message.method === CancelNotification.type.method) {
          let key = createRequestQueueKey(message.params.id);
          let toCancel = messageQueue.get(key);
          if (messages_1.isRequestMessage(toCancel)) {
            let response = strategy && strategy.cancelUndispatched ? strategy.cancelUndispatched(toCancel, cancelUndispatched) : cancelUndispatched(toCancel);
            if (response && (response.error !== void 0 || response.result !== void 0)) {
              messageQueue.delete(key);
              response.id = toCancel.id;
              traceSendingResponse(response, message.method, Date.now());
              messageWriter.write(response);
              return;
            }
          }
        }
        addMessageToQueue(messageQueue, message);
      } finally {
        triggerMessageQueue();
      }
    };
    function handleRequest(requestMessage) {
      if (isDisposed()) {
        return;
      }
      function reply(resultOrError, method, startTime2) {
        let message = {
          jsonrpc: version,
          id: requestMessage.id
        };
        if (resultOrError instanceof messages_1.ResponseError) {
          message.error = resultOrError.toJson();
        } else {
          message.result = resultOrError === void 0 ? null : resultOrError;
        }
        traceSendingResponse(message, method, startTime2);
        messageWriter.write(message);
      }
      function replyError(error, method, startTime2) {
        let message = {
          jsonrpc: version,
          id: requestMessage.id,
          error: error.toJson()
        };
        traceSendingResponse(message, method, startTime2);
        messageWriter.write(message);
      }
      function replySuccess(result, method, startTime2) {
        if (result === void 0) {
          result = null;
        }
        let message = {
          jsonrpc: version,
          id: requestMessage.id,
          result
        };
        traceSendingResponse(message, method, startTime2);
        messageWriter.write(message);
      }
      traceReceivedRequest(requestMessage);
      let element = requestHandlers[requestMessage.method];
      let type;
      let requestHandler;
      if (element) {
        type = element.type;
        requestHandler = element.handler;
      }
      let startTime = Date.now();
      if (requestHandler || starRequestHandler) {
        let cancellationSource = new cancellation_1.CancellationTokenSource();
        let tokenKey = String(requestMessage.id);
        requestTokens[tokenKey] = cancellationSource;
        try {
          let handlerResult;
          if (requestMessage.params === void 0 || type !== void 0 && type.numberOfParams === 0) {
            handlerResult = requestHandler ? requestHandler(cancellationSource.token) : starRequestHandler(requestMessage.method, cancellationSource.token);
          } else if (Is.array(requestMessage.params) && (type === void 0 || type.numberOfParams > 1)) {
            handlerResult = requestHandler ? requestHandler(...requestMessage.params, cancellationSource.token) : starRequestHandler(requestMessage.method, ...requestMessage.params, cancellationSource.token);
          } else {
            handlerResult = requestHandler ? requestHandler(requestMessage.params, cancellationSource.token) : starRequestHandler(requestMessage.method, requestMessage.params, cancellationSource.token);
          }
          let promise = handlerResult;
          if (!handlerResult) {
            delete requestTokens[tokenKey];
            replySuccess(handlerResult, requestMessage.method, startTime);
          } else if (promise.then) {
            promise.then((resultOrError) => {
              delete requestTokens[tokenKey];
              reply(resultOrError, requestMessage.method, startTime);
            }, (error) => {
              delete requestTokens[tokenKey];
              if (error instanceof messages_1.ResponseError) {
                replyError(error, requestMessage.method, startTime);
              } else if (error && Is.string(error.message)) {
                replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
              } else {
                replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
              }
            });
          } else {
            delete requestTokens[tokenKey];
            reply(handlerResult, requestMessage.method, startTime);
          }
        } catch (error) {
          delete requestTokens[tokenKey];
          if (error instanceof messages_1.ResponseError) {
            reply(error, requestMessage.method, startTime);
          } else if (error && Is.string(error.message)) {
            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
          } else {
            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
          }
        }
      } else {
        replyError(new messages_1.ResponseError(messages_1.ErrorCodes.MethodNotFound, `Unhandled method ${requestMessage.method}`), requestMessage.method, startTime);
      }
    }
    function handleResponse(responseMessage) {
      if (isDisposed()) {
        return;
      }
      if (responseMessage.id === null) {
        if (responseMessage.error) {
          logger.error(`Received response message without id: Error is: 
${JSON.stringify(responseMessage.error, void 0, 4)}`);
        } else {
          logger.error(`Received response message without id. No further error information provided.`);
        }
      } else {
        let key = String(responseMessage.id);
        let responsePromise = responsePromises[key];
        traceReceivedResponse(responseMessage, responsePromise);
        if (responsePromise) {
          delete responsePromises[key];
          try {
            if (responseMessage.error) {
              let error = responseMessage.error;
              responsePromise.reject(new messages_1.ResponseError(error.code, error.message, error.data));
            } else if (responseMessage.result !== void 0) {
              responsePromise.resolve(responseMessage.result);
            } else {
              throw new Error("Should never happen.");
            }
          } catch (error) {
            if (error.message) {
              logger.error(`Response handler '${responsePromise.method}' failed with message: ${error.message}`);
            } else {
              logger.error(`Response handler '${responsePromise.method}' failed unexpectedly.`);
            }
          }
        }
      }
    }
    function handleNotification(message) {
      if (isDisposed()) {
        return;
      }
      let type = void 0;
      let notificationHandler;
      if (message.method === CancelNotification.type.method) {
        notificationHandler = (params) => {
          let id = params.id;
          let source = requestTokens[String(id)];
          if (source) {
            source.cancel();
          }
        };
      } else {
        let element = notificationHandlers[message.method];
        if (element) {
          notificationHandler = element.handler;
          type = element.type;
        }
      }
      if (notificationHandler || starNotificationHandler) {
        try {
          traceReceivedNotification(message);
          if (message.params === void 0 || type !== void 0 && type.numberOfParams === 0) {
            notificationHandler ? notificationHandler() : starNotificationHandler(message.method);
          } else if (Is.array(message.params) && (type === void 0 || type.numberOfParams > 1)) {
            notificationHandler ? notificationHandler(...message.params) : starNotificationHandler(message.method, ...message.params);
          } else {
            notificationHandler ? notificationHandler(message.params) : starNotificationHandler(message.method, message.params);
          }
        } catch (error) {
          if (error.message) {
            logger.error(`Notification handler '${message.method}' failed with message: ${error.message}`);
          } else {
            logger.error(`Notification handler '${message.method}' failed unexpectedly.`);
          }
        }
      } else {
        unhandledNotificationEmitter.fire(message);
      }
    }
    function handleInvalidMessage(message) {
      if (!message) {
        logger.error("Received empty message.");
        return;
      }
      logger.error(`Received message which is neither a response nor a notification message:
${JSON.stringify(message, null, 4)}`);
      let responseMessage = message;
      if (Is.string(responseMessage.id) || Is.number(responseMessage.id)) {
        let key = String(responseMessage.id);
        let responseHandler = responsePromises[key];
        if (responseHandler) {
          responseHandler.reject(new Error("The received response has neither a result nor an error property."));
        }
      }
    }
    function traceSendingRequest(message) {
      if (trace === Trace.Off || !tracer) {
        return;
      }
      if (traceFormat === TraceFormat.Text) {
        let data = void 0;
        if (trace === Trace.Verbose && message.params) {
          data = `Params: ${JSON.stringify(message.params, null, 4)}

`;
        }
        tracer.log(`Sending request '${message.method} - (${message.id})'.`, data);
      } else {
        logLSPMessage("send-request", message);
      }
    }
    function traceSendingNotification(message) {
      if (trace === Trace.Off || !tracer) {
        return;
      }
      if (traceFormat === TraceFormat.Text) {
        let data = void 0;
        if (trace === Trace.Verbose) {
          if (message.params) {
            data = `Params: ${JSON.stringify(message.params, null, 4)}

`;
          } else {
            data = "No parameters provided.\n\n";
          }
        }
        tracer.log(`Sending notification '${message.method}'.`, data);
      } else {
        logLSPMessage("send-notification", message);
      }
    }
    function traceSendingResponse(message, method, startTime) {
      if (trace === Trace.Off || !tracer) {
        return;
      }
      if (traceFormat === TraceFormat.Text) {
        let data = void 0;
        if (trace === Trace.Verbose) {
          if (message.error && message.error.data) {
            data = `Error data: ${JSON.stringify(message.error.data, null, 4)}

`;
          } else {
            if (message.result) {
              data = `Result: ${JSON.stringify(message.result, null, 4)}

`;
            } else if (message.error === void 0) {
              data = "No result returned.\n\n";
            }
          }
        }
        tracer.log(`Sending response '${method} - (${message.id})'. Processing request took ${Date.now() - startTime}ms`, data);
      } else {
        logLSPMessage("send-response", message);
      }
    }
    function traceReceivedRequest(message) {
      if (trace === Trace.Off || !tracer) {
        return;
      }
      if (traceFormat === TraceFormat.Text) {
        let data = void 0;
        if (trace === Trace.Verbose && message.params) {
          data = `Params: ${JSON.stringify(message.params, null, 4)}

`;
        }
        tracer.log(`Received request '${message.method} - (${message.id})'.`, data);
      } else {
        logLSPMessage("receive-request", message);
      }
    }
    function traceReceivedNotification(message) {
      if (trace === Trace.Off || !tracer || message.method === LogTraceNotification.type.method) {
        return;
      }
      if (traceFormat === TraceFormat.Text) {
        let data = void 0;
        if (trace === Trace.Verbose) {
          if (message.params) {
            data = `Params: ${JSON.stringify(message.params, null, 4)}

`;
          } else {
            data = "No parameters provided.\n\n";
          }
        }
        tracer.log(`Received notification '${message.method}'.`, data);
      } else {
        logLSPMessage("receive-notification", message);
      }
    }
    function traceReceivedResponse(message, responsePromise) {
      if (trace === Trace.Off || !tracer) {
        return;
      }
      if (traceFormat === TraceFormat.Text) {
        let data = void 0;
        if (trace === Trace.Verbose) {
          if (message.error && message.error.data) {
            data = `Error data: ${JSON.stringify(message.error.data, null, 4)}

`;
          } else {
            if (message.result) {
              data = `Result: ${JSON.stringify(message.result, null, 4)}

`;
            } else if (message.error === void 0) {
              data = "No result returned.\n\n";
            }
          }
        }
        if (responsePromise) {
          let error = message.error ? ` Request failed: ${message.error.message} (${message.error.code}).` : "";
          tracer.log(`Received response '${responsePromise.method} - (${message.id})' in ${Date.now() - responsePromise.timerStart}ms.${error}`, data);
        } else {
          tracer.log(`Received response ${message.id} without active response promise.`, data);
        }
      } else {
        logLSPMessage("receive-response", message);
      }
    }
    function logLSPMessage(type, message) {
      if (!tracer || trace === Trace.Off) {
        return;
      }
      const lspMessage = {
        isLSPMessage: true,
        type,
        message,
        timestamp: Date.now()
      };
      tracer.log(lspMessage);
    }
    function throwIfClosedOrDisposed() {
      if (isClosed()) {
        throw new ConnectionError(ConnectionErrors.Closed, "Connection is closed.");
      }
      if (isDisposed()) {
        throw new ConnectionError(ConnectionErrors.Disposed, "Connection is disposed.");
      }
    }
    function throwIfListening() {
      if (isListening()) {
        throw new ConnectionError(ConnectionErrors.AlreadyListening, "Connection is already listening");
      }
    }
    function throwIfNotListening() {
      if (!isListening()) {
        throw new Error("Call listen() first.");
      }
    }
    function undefinedToNull(param) {
      if (param === void 0) {
        return null;
      } else {
        return param;
      }
    }
    function computeMessageParams(type, params) {
      let result;
      let numberOfParams = type.numberOfParams;
      switch (numberOfParams) {
        case 0:
          result = null;
          break;
        case 1:
          result = undefinedToNull(params[0]);
          break;
        default:
          result = [];
          for (let i = 0; i < params.length && i < numberOfParams; i++) {
            result.push(undefinedToNull(params[i]));
          }
          if (params.length < numberOfParams) {
            for (let i = params.length; i < numberOfParams; i++) {
              result.push(null);
            }
          }
          break;
      }
      return result;
    }
    let connection = {
      sendNotification: (type, ...params) => {
        throwIfClosedOrDisposed();
        let method;
        let messageParams;
        if (Is.string(type)) {
          method = type;
          switch (params.length) {
            case 0:
              messageParams = null;
              break;
            case 1:
              messageParams = params[0];
              break;
            default:
              messageParams = params;
              break;
          }
        } else {
          method = type.method;
          messageParams = computeMessageParams(type, params);
        }
        let notificationMessage = {
          jsonrpc: version,
          method,
          params: messageParams
        };
        traceSendingNotification(notificationMessage);
        messageWriter.write(notificationMessage);
      },
      onNotification: (type, handler) => {
        throwIfClosedOrDisposed();
        if (Is.func(type)) {
          starNotificationHandler = type;
        } else if (handler) {
          if (Is.string(type)) {
            notificationHandlers[type] = {type: void 0, handler};
          } else {
            notificationHandlers[type.method] = {type, handler};
          }
        }
      },
      onProgress: (_type, token, handler) => {
        if (progressHandlers.has(token)) {
          throw new Error(`Progress handler for token ${token} already registered`);
        }
        progressHandlers.set(token, handler);
        return {
          dispose: () => {
            progressHandlers.delete(token);
          }
        };
      },
      sendProgress: (_type, token, value) => {
        connection.sendNotification(ProgressNotification.type, {token, value});
      },
      onUnhandledProgress: unhandledProgressEmitter.event,
      sendRequest: (type, ...params) => {
        throwIfClosedOrDisposed();
        throwIfNotListening();
        let method;
        let messageParams;
        let token = void 0;
        if (Is.string(type)) {
          method = type;
          switch (params.length) {
            case 0:
              messageParams = null;
              break;
            case 1:
              if (cancellation_1.CancellationToken.is(params[0])) {
                messageParams = null;
                token = params[0];
              } else {
                messageParams = undefinedToNull(params[0]);
              }
              break;
            default:
              const last = params.length - 1;
              if (cancellation_1.CancellationToken.is(params[last])) {
                token = params[last];
                if (params.length === 2) {
                  messageParams = undefinedToNull(params[0]);
                } else {
                  messageParams = params.slice(0, last).map((value) => undefinedToNull(value));
                }
              } else {
                messageParams = params.map((value) => undefinedToNull(value));
              }
              break;
          }
        } else {
          method = type.method;
          messageParams = computeMessageParams(type, params);
          let numberOfParams = type.numberOfParams;
          token = cancellation_1.CancellationToken.is(params[numberOfParams]) ? params[numberOfParams] : void 0;
        }
        let id = sequenceNumber++;
        let result = new Promise((resolve, reject) => {
          let requestMessage = {
            jsonrpc: version,
            id,
            method,
            params: messageParams
          };
          let responsePromise = {method, timerStart: Date.now(), resolve, reject};
          traceSendingRequest(requestMessage);
          try {
            messageWriter.write(requestMessage);
          } catch (e) {
            responsePromise.reject(new messages_1.ResponseError(messages_1.ErrorCodes.MessageWriteError, e.message ? e.message : "Unknown reason"));
            responsePromise = null;
          }
          if (responsePromise) {
            responsePromises[String(id)] = responsePromise;
          }
        });
        if (token) {
          token.onCancellationRequested(() => {
            connection.sendNotification(CancelNotification.type, {id});
          });
        }
        return result;
      },
      onRequest: (type, handler) => {
        throwIfClosedOrDisposed();
        if (Is.func(type)) {
          starRequestHandler = type;
        } else if (handler) {
          if (Is.string(type)) {
            requestHandlers[type] = {type: void 0, handler};
          } else {
            requestHandlers[type.method] = {type, handler};
          }
        }
      },
      trace: (_value, _tracer, sendNotificationOrTraceOptions) => {
        let _sendNotification = false;
        let _traceFormat = TraceFormat.Text;
        if (sendNotificationOrTraceOptions !== void 0) {
          if (Is.boolean(sendNotificationOrTraceOptions)) {
            _sendNotification = sendNotificationOrTraceOptions;
          } else {
            _sendNotification = sendNotificationOrTraceOptions.sendNotification || false;
            _traceFormat = sendNotificationOrTraceOptions.traceFormat || TraceFormat.Text;
          }
        }
        trace = _value;
        traceFormat = _traceFormat;
        if (trace === Trace.Off) {
          tracer = void 0;
        } else {
          tracer = _tracer;
        }
        if (_sendNotification && !isClosed() && !isDisposed()) {
          connection.sendNotification(SetTraceNotification.type, {value: Trace.toString(_value)});
        }
      },
      onError: errorEmitter.event,
      onClose: closeEmitter.event,
      onUnhandledNotification: unhandledNotificationEmitter.event,
      onDispose: disposeEmitter.event,
      dispose: () => {
        if (isDisposed()) {
          return;
        }
        state = ConnectionState.Disposed;
        disposeEmitter.fire(void 0);
        let error = new Error("Connection got disposed.");
        Object.keys(responsePromises).forEach((key) => {
          responsePromises[key].reject(error);
        });
        responsePromises = Object.create(null);
        requestTokens = Object.create(null);
        messageQueue = new linkedMap_1.LinkedMap();
        if (Is.func(messageWriter.dispose)) {
          messageWriter.dispose();
        }
        if (Is.func(messageReader.dispose)) {
          messageReader.dispose();
        }
      },
      listen: () => {
        throwIfClosedOrDisposed();
        throwIfListening();
        state = ConnectionState.Listening;
        messageReader.listen(callback);
      },
      inspect: () => {
        console.log("inspect");
      }
    };
    connection.onNotification(LogTraceNotification.type, (params) => {
      if (trace === Trace.Off || !tracer) {
        return;
      }
      tracer.log(params.message, trace === Trace.Verbose ? params.verbose : void 0);
    });
    connection.onNotification(ProgressNotification.type, (params) => {
      const handler = progressHandlers.get(params.token);
      if (handler) {
        handler(params.value);
      } else {
        unhandledProgressEmitter.fire(params);
      }
    });
    return connection;
  }
  function isMessageReader(value) {
    return value.listen !== void 0 && value.read === void 0;
  }
  function isMessageWriter(value) {
    return value.write !== void 0 && value.end === void 0;
  }
  function createMessageConnection(input, output, logger, strategy) {
    if (!logger) {
      logger = exports2.NullLogger;
    }
    let reader = isMessageReader(input) ? input : new messageReader_1.StreamMessageReader(input);
    let writer = isMessageWriter(output) ? output : new messageWriter_1.StreamMessageWriter(output);
    return _createMessageConnection(reader, writer, logger, strategy);
  }
  exports2.createMessageConnection = createMessageConnection;
});

// node_modules/vscode-languageserver-types/lib/esm/main.js
var require_main2 = __commonJS((exports2) => {
  __markAsModule(exports2);
  __export(exports2, {
    CodeAction: () => CodeAction3,
    CodeActionContext: () => CodeActionContext,
    CodeActionKind: () => CodeActionKind2,
    CodeLens: () => CodeLens,
    Color: () => Color,
    ColorInformation: () => ColorInformation,
    ColorPresentation: () => ColorPresentation,
    Command: () => Command2,
    CompletionItem: () => CompletionItem,
    CompletionItemKind: () => CompletionItemKind,
    CompletionItemTag: () => CompletionItemTag,
    CompletionList: () => CompletionList,
    CreateFile: () => CreateFile,
    DeleteFile: () => DeleteFile,
    Diagnostic: () => Diagnostic,
    DiagnosticRelatedInformation: () => DiagnosticRelatedInformation,
    DiagnosticSeverity: () => DiagnosticSeverity,
    DiagnosticTag: () => DiagnosticTag,
    DocumentHighlight: () => DocumentHighlight,
    DocumentHighlightKind: () => DocumentHighlightKind,
    DocumentLink: () => DocumentLink,
    DocumentSymbol: () => DocumentSymbol,
    EOL: () => EOL,
    FoldingRange: () => FoldingRange,
    FoldingRangeKind: () => FoldingRangeKind,
    FormattingOptions: () => FormattingOptions,
    Hover: () => Hover,
    InsertTextFormat: () => InsertTextFormat,
    Location: () => Location2,
    LocationLink: () => LocationLink2,
    MarkedString: () => MarkedString,
    MarkupContent: () => MarkupContent,
    MarkupKind: () => MarkupKind,
    ParameterInformation: () => ParameterInformation,
    Position: () => Position2,
    Range: () => Range2,
    RenameFile: () => RenameFile,
    SelectionRange: () => SelectionRange,
    SignatureInformation: () => SignatureInformation,
    SymbolInformation: () => SymbolInformation,
    SymbolKind: () => SymbolKind,
    SymbolTag: () => SymbolTag,
    TextDocument: () => TextDocument,
    TextDocumentEdit: () => TextDocumentEdit2,
    TextDocumentIdentifier: () => TextDocumentIdentifier,
    TextDocumentItem: () => TextDocumentItem,
    TextEdit: () => TextEdit2,
    VersionedTextDocumentIdentifier: () => VersionedTextDocumentIdentifier,
    WorkspaceChange: () => WorkspaceChange,
    WorkspaceEdit: () => WorkspaceEdit2
  });
  "use strict";
  var Position2;
  (function(Position3) {
    function create(line, character) {
      return {line, character};
    }
    Position3.create = create;
    function is(value) {
      var candidate = value;
      return Is.objectLiteral(candidate) && Is.number(candidate.line) && Is.number(candidate.character);
    }
    Position3.is = is;
  })(Position2 || (Position2 = {}));
  var Range2;
  (function(Range3) {
    function create(one, two, three, four) {
      if (Is.number(one) && Is.number(two) && Is.number(three) && Is.number(four)) {
        return {start: Position2.create(one, two), end: Position2.create(three, four)};
      } else if (Position2.is(one) && Position2.is(two)) {
        return {start: one, end: two};
      } else {
        throw new Error("Range#create called with invalid arguments[" + one + ", " + two + ", " + three + ", " + four + "]");
      }
    }
    Range3.create = create;
    function is(value) {
      var candidate = value;
      return Is.objectLiteral(candidate) && Position2.is(candidate.start) && Position2.is(candidate.end);
    }
    Range3.is = is;
  })(Range2 || (Range2 = {}));
  var Location2;
  (function(Location3) {
    function create(uri, range) {
      return {uri, range};
    }
    Location3.create = create;
    function is(value) {
      var candidate = value;
      return Is.defined(candidate) && Range2.is(candidate.range) && (Is.string(candidate.uri) || Is.undefined(candidate.uri));
    }
    Location3.is = is;
  })(Location2 || (Location2 = {}));
  var LocationLink2;
  (function(LocationLink3) {
    function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {
      return {targetUri, targetRange, targetSelectionRange, originSelectionRange};
    }
    LocationLink3.create = create;
    function is(value) {
      var candidate = value;
      return Is.defined(candidate) && Range2.is(candidate.targetRange) && Is.string(candidate.targetUri) && (Range2.is(candidate.targetSelectionRange) || Is.undefined(candidate.targetSelectionRange)) && (Range2.is(candidate.originSelectionRange) || Is.undefined(candidate.originSelectionRange));
    }
    LocationLink3.is = is;
  })(LocationLink2 || (LocationLink2 = {}));
  var Color;
  (function(Color2) {
    function create(red, green, blue, alpha) {
      return {
        red,
        green,
        blue,
        alpha
      };
    }
    Color2.create = create;
    function is(value) {
      var candidate = value;
      return Is.number(candidate.red) && Is.number(candidate.green) && Is.number(candidate.blue) && Is.number(candidate.alpha);
    }
    Color2.is = is;
  })(Color || (Color = {}));
  var ColorInformation;
  (function(ColorInformation2) {
    function create(range, color) {
      return {
        range,
        color
      };
    }
    ColorInformation2.create = create;
    function is(value) {
      var candidate = value;
      return Range2.is(candidate.range) && Color.is(candidate.color);
    }
    ColorInformation2.is = is;
  })(ColorInformation || (ColorInformation = {}));
  var ColorPresentation;
  (function(ColorPresentation2) {
    function create(label, textEdit, additionalTextEdits) {
      return {
        label,
        textEdit,
        additionalTextEdits
      };
    }
    ColorPresentation2.create = create;
    function is(value) {
      var candidate = value;
      return Is.string(candidate.label) && (Is.undefined(candidate.textEdit) || TextEdit2.is(candidate)) && (Is.undefined(candidate.additionalTextEdits) || Is.typedArray(candidate.additionalTextEdits, TextEdit2.is));
    }
    ColorPresentation2.is = is;
  })(ColorPresentation || (ColorPresentation = {}));
  var FoldingRangeKind;
  (function(FoldingRangeKind2) {
    FoldingRangeKind2["Comment"] = "comment";
    FoldingRangeKind2["Imports"] = "imports";
    FoldingRangeKind2["Region"] = "region";
  })(FoldingRangeKind || (FoldingRangeKind = {}));
  var FoldingRange;
  (function(FoldingRange2) {
    function create(startLine, endLine, startCharacter, endCharacter, kind) {
      var result = {
        startLine,
        endLine
      };
      if (Is.defined(startCharacter)) {
        result.startCharacter = startCharacter;
      }
      if (Is.defined(endCharacter)) {
        result.endCharacter = endCharacter;
      }
      if (Is.defined(kind)) {
        result.kind = kind;
      }
      return result;
    }
    FoldingRange2.create = create;
    function is(value) {
      var candidate = value;
      return Is.number(candidate.startLine) && Is.number(candidate.startLine) && (Is.undefined(candidate.startCharacter) || Is.number(candidate.startCharacter)) && (Is.undefined(candidate.endCharacter) || Is.number(candidate.endCharacter)) && (Is.undefined(candidate.kind) || Is.string(candidate.kind));
    }
    FoldingRange2.is = is;
  })(FoldingRange || (FoldingRange = {}));
  var DiagnosticRelatedInformation;
  (function(DiagnosticRelatedInformation2) {
    function create(location, message) {
      return {
        location,
        message
      };
    }
    DiagnosticRelatedInformation2.create = create;
    function is(value) {
      var candidate = value;
      return Is.defined(candidate) && Location2.is(candidate.location) && Is.string(candidate.message);
    }
    DiagnosticRelatedInformation2.is = is;
  })(DiagnosticRelatedInformation || (DiagnosticRelatedInformation = {}));
  var DiagnosticSeverity;
  (function(DiagnosticSeverity2) {
    DiagnosticSeverity2.Error = 1;
    DiagnosticSeverity2.Warning = 2;
    DiagnosticSeverity2.Information = 3;
    DiagnosticSeverity2.Hint = 4;
  })(DiagnosticSeverity || (DiagnosticSeverity = {}));
  var DiagnosticTag;
  (function(DiagnosticTag2) {
    DiagnosticTag2.Unnecessary = 1;
    DiagnosticTag2.Deprecated = 2;
  })(DiagnosticTag || (DiagnosticTag = {}));
  var Diagnostic;
  (function(Diagnostic2) {
    function create(range, message, severity, code, source, relatedInformation) {
      var result = {range, message};
      if (Is.defined(severity)) {
        result.severity = severity;
      }
      if (Is.defined(code)) {
        result.code = code;
      }
      if (Is.defined(source)) {
        result.source = source;
      }
      if (Is.defined(relatedInformation)) {
        result.relatedInformation = relatedInformation;
      }
      return result;
    }
    Diagnostic2.create = create;
    function is(value) {
      var candidate = value;
      return Is.defined(candidate) && Range2.is(candidate.range) && Is.string(candidate.message) && (Is.number(candidate.severity) || Is.undefined(candidate.severity)) && (Is.number(candidate.code) || Is.string(candidate.code) || Is.undefined(candidate.code)) && (Is.string(candidate.source) || Is.undefined(candidate.source)) && (Is.undefined(candidate.relatedInformation) || Is.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation.is));
    }
    Diagnostic2.is = is;
  })(Diagnostic || (Diagnostic = {}));
  var Command2;
  (function(Command3) {
    function create(title, command) {
      var args = [];
      for (var _i = 2; _i < arguments.length; _i++) {
        args[_i - 2] = arguments[_i];
      }
      var result = {title, command};
      if (Is.defined(args) && args.length > 0) {
        result.arguments = args;
      }
      return result;
    }
    Command3.create = create;
    function is(value) {
      var candidate = value;
      return Is.defined(candidate) && Is.string(candidate.title) && Is.string(candidate.command);
    }
    Command3.is = is;
  })(Command2 || (Command2 = {}));
  var TextEdit2;
  (function(TextEdit3) {
    function replace(range, newText) {
      return {range, newText};
    }
    TextEdit3.replace = replace;
    function insert(position, newText) {
      return {range: {start: position, end: position}, newText};
    }
    TextEdit3.insert = insert;
    function del(range) {
      return {range, newText: ""};
    }
    TextEdit3.del = del;
    function is(value) {
      var candidate = value;
      return Is.objectLiteral(candidate) && Is.string(candidate.newText) && Range2.is(candidate.range);
    }
    TextEdit3.is = is;
  })(TextEdit2 || (TextEdit2 = {}));
  var TextDocumentEdit2;
  (function(TextDocumentEdit3) {
    function create(textDocument, edits) {
      return {textDocument, edits};
    }
    TextDocumentEdit3.create = create;
    function is(value) {
      var candidate = value;
      return Is.defined(candidate) && VersionedTextDocumentIdentifier.is(candidate.textDocument) && Array.isArray(candidate.edits);
    }
    TextDocumentEdit3.is = is;
  })(TextDocumentEdit2 || (TextDocumentEdit2 = {}));
  var CreateFile;
  (function(CreateFile2) {
    function create(uri, options) {
      var result = {
        kind: "create",
        uri
      };
      if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {
        result.options = options;
      }
      return result;
    }
    CreateFile2.create = create;
    function is(value) {
      var candidate = value;
      return candidate && candidate.kind === "create" && Is.string(candidate.uri) && (candidate.options === void 0 || (candidate.options.overwrite === void 0 || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is.boolean(candidate.options.ignoreIfExists)));
    }
    CreateFile2.is = is;
  })(CreateFile || (CreateFile = {}));
  var RenameFile;
  (function(RenameFile2) {
    function create(oldUri, newUri, options) {
      var result = {
        kind: "rename",
        oldUri,
        newUri
      };
      if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {
        result.options = options;
      }
      return result;
    }
    RenameFile2.create = create;
    function is(value) {
      var candidate = value;
      return candidate && candidate.kind === "rename" && Is.string(candidate.oldUri) && Is.string(candidate.newUri) && (candidate.options === void 0 || (candidate.options.overwrite === void 0 || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is.boolean(candidate.options.ignoreIfExists)));
    }
    RenameFile2.is = is;
  })(RenameFile || (RenameFile = {}));
  var DeleteFile;
  (function(DeleteFile2) {
    function create(uri, options) {
      var result = {
        kind: "delete",
        uri
      };
      if (options !== void 0 && (options.recursive !== void 0 || options.ignoreIfNotExists !== void 0)) {
        result.options = options;
      }
      return result;
    }
    DeleteFile2.create = create;
    function is(value) {
      var candidate = value;
      return candidate && candidate.kind === "delete" && Is.string(candidate.uri) && (candidate.options === void 0 || (candidate.options.recursive === void 0 || Is.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === void 0 || Is.boolean(candidate.options.ignoreIfNotExists)));
    }
    DeleteFile2.is = is;
  })(DeleteFile || (DeleteFile = {}));
  var WorkspaceEdit2;
  (function(WorkspaceEdit3) {
    function is(value) {
      var candidate = value;
      return candidate && (candidate.changes !== void 0 || candidate.documentChanges !== void 0) && (candidate.documentChanges === void 0 || candidate.documentChanges.every(function(change) {
        if (Is.string(change.kind)) {
          return CreateFile.is(change) || RenameFile.is(change) || DeleteFile.is(change);
        } else {
          return TextDocumentEdit2.is(change);
        }
      }));
    }
    WorkspaceEdit3.is = is;
  })(WorkspaceEdit2 || (WorkspaceEdit2 = {}));
  var TextEditChangeImpl = function() {
    function TextEditChangeImpl2(edits) {
      this.edits = edits;
    }
    TextEditChangeImpl2.prototype.insert = function(position, newText) {
      this.edits.push(TextEdit2.insert(position, newText));
    };
    TextEditChangeImpl2.prototype.replace = function(range, newText) {
      this.edits.push(TextEdit2.replace(range, newText));
    };
    TextEditChangeImpl2.prototype.delete = function(range) {
      this.edits.push(TextEdit2.del(range));
    };
    TextEditChangeImpl2.prototype.add = function(edit) {
      this.edits.push(edit);
    };
    TextEditChangeImpl2.prototype.all = function() {
      return this.edits;
    };
    TextEditChangeImpl2.prototype.clear = function() {
      this.edits.splice(0, this.edits.length);
    };
    return TextEditChangeImpl2;
  }();
  var WorkspaceChange = function() {
    function WorkspaceChange2(workspaceEdit) {
      var _this = this;
      this._textEditChanges = Object.create(null);
      if (workspaceEdit) {
        this._workspaceEdit = workspaceEdit;
        if (workspaceEdit.documentChanges) {
          workspaceEdit.documentChanges.forEach(function(change) {
            if (TextDocumentEdit2.is(change)) {
              var textEditChange = new TextEditChangeImpl(change.edits);
              _this._textEditChanges[change.textDocument.uri] = textEditChange;
            }
          });
        } else if (workspaceEdit.changes) {
          Object.keys(workspaceEdit.changes).forEach(function(key) {
            var textEditChange = new TextEditChangeImpl(workspaceEdit.changes[key]);
            _this._textEditChanges[key] = textEditChange;
          });
        }
      }
    }
    Object.defineProperty(WorkspaceChange2.prototype, "edit", {
      get: function() {
        return this._workspaceEdit;
      },
      enumerable: true,
      configurable: true
    });
    WorkspaceChange2.prototype.getTextEditChange = function(key) {
      if (VersionedTextDocumentIdentifier.is(key)) {
        if (!this._workspaceEdit) {
          this._workspaceEdit = {
            documentChanges: []
          };
        }
        if (!this._workspaceEdit.documentChanges) {
          throw new Error("Workspace edit is not configured for document changes.");
        }
        var textDocument = key;
        var result = this._textEditChanges[textDocument.uri];
        if (!result) {
          var edits = [];
          var textDocumentEdit = {
            textDocument,
            edits
          };
          this._workspaceEdit.documentChanges.push(textDocumentEdit);
          result = new TextEditChangeImpl(edits);
          this._textEditChanges[textDocument.uri] = result;
        }
        return result;
      } else {
        if (!this._workspaceEdit) {
          this._workspaceEdit = {
            changes: Object.create(null)
          };
        }
        if (!this._workspaceEdit.changes) {
          throw new Error("Workspace edit is not configured for normal text edit changes.");
        }
        var result = this._textEditChanges[key];
        if (!result) {
          var edits = [];
          this._workspaceEdit.changes[key] = edits;
          result = new TextEditChangeImpl(edits);
          this._textEditChanges[key] = result;
        }
        return result;
      }
    };
    WorkspaceChange2.prototype.createFile = function(uri, options) {
      this.checkDocumentChanges();
      this._workspaceEdit.documentChanges.push(CreateFile.create(uri, options));
    };
    WorkspaceChange2.prototype.renameFile = function(oldUri, newUri, options) {
      this.checkDocumentChanges();
      this._workspaceEdit.documentChanges.push(RenameFile.create(oldUri, newUri, options));
    };
    WorkspaceChange2.prototype.deleteFile = function(uri, options) {
      this.checkDocumentChanges();
      this._workspaceEdit.documentChanges.push(DeleteFile.create(uri, options));
    };
    WorkspaceChange2.prototype.checkDocumentChanges = function() {
      if (!this._workspaceEdit || !this._workspaceEdit.documentChanges) {
        throw new Error("Workspace edit is not configured for document changes.");
      }
    };
    return WorkspaceChange2;
  }();
  var TextDocumentIdentifier;
  (function(TextDocumentIdentifier2) {
    function create(uri) {
      return {uri};
    }
    TextDocumentIdentifier2.create = create;
    function is(value) {
      var candidate = value;
      return Is.defined(candidate) && Is.string(candidate.uri);
    }
    TextDocumentIdentifier2.is = is;
  })(TextDocumentIdentifier || (TextDocumentIdentifier = {}));
  var VersionedTextDocumentIdentifier;
  (function(VersionedTextDocumentIdentifier2) {
    function create(uri, version) {
      return {uri, version};
    }
    VersionedTextDocumentIdentifier2.create = create;
    function is(value) {
      var candidate = value;
      return Is.defined(candidate) && Is.string(candidate.uri) && (candidate.version === null || Is.number(candidate.version));
    }
    VersionedTextDocumentIdentifier2.is = is;
  })(VersionedTextDocumentIdentifier || (VersionedTextDocumentIdentifier = {}));
  var TextDocumentItem;
  (function(TextDocumentItem2) {
    function create(uri, languageId, version, text) {
      return {uri, languageId, version, text};
    }
    TextDocumentItem2.create = create;
    function is(value) {
      var candidate = value;
      return Is.defined(candidate) && Is.string(candidate.uri) && Is.string(candidate.languageId) && Is.number(candidate.version) && Is.string(candidate.text);
    }
    TextDocumentItem2.is = is;
  })(TextDocumentItem || (TextDocumentItem = {}));
  var MarkupKind;
  (function(MarkupKind2) {
    MarkupKind2.PlainText = "plaintext";
    MarkupKind2.Markdown = "markdown";
  })(MarkupKind || (MarkupKind = {}));
  (function(MarkupKind2) {
    function is(value) {
      var candidate = value;
      return candidate === MarkupKind2.PlainText || candidate === MarkupKind2.Markdown;
    }
    MarkupKind2.is = is;
  })(MarkupKind || (MarkupKind = {}));
  var MarkupContent;
  (function(MarkupContent2) {
    function is(value) {
      var candidate = value;
      return Is.objectLiteral(value) && MarkupKind.is(candidate.kind) && Is.string(candidate.value);
    }
    MarkupContent2.is = is;
  })(MarkupContent || (MarkupContent = {}));
  var CompletionItemKind;
  (function(CompletionItemKind2) {
    CompletionItemKind2.Text = 1;
    CompletionItemKind2.Method = 2;
    CompletionItemKind2.Function = 3;
    CompletionItemKind2.Constructor = 4;
    CompletionItemKind2.Field = 5;
    CompletionItemKind2.Variable = 6;
    CompletionItemKind2.Class = 7;
    CompletionItemKind2.Interface = 8;
    CompletionItemKind2.Module = 9;
    CompletionItemKind2.Property = 10;
    CompletionItemKind2.Unit = 11;
    CompletionItemKind2.Value = 12;
    CompletionItemKind2.Enum = 13;
    CompletionItemKind2.Keyword = 14;
    CompletionItemKind2.Snippet = 15;
    CompletionItemKind2.Color = 16;
    CompletionItemKind2.File = 17;
    CompletionItemKind2.Reference = 18;
    CompletionItemKind2.Folder = 19;
    CompletionItemKind2.EnumMember = 20;
    CompletionItemKind2.Constant = 21;
    CompletionItemKind2.Struct = 22;
    CompletionItemKind2.Event = 23;
    CompletionItemKind2.Operator = 24;
    CompletionItemKind2.TypeParameter = 25;
  })(CompletionItemKind || (CompletionItemKind = {}));
  var InsertTextFormat;
  (function(InsertTextFormat2) {
    InsertTextFormat2.PlainText = 1;
    InsertTextFormat2.Snippet = 2;
  })(InsertTextFormat || (InsertTextFormat = {}));
  var CompletionItemTag;
  (function(CompletionItemTag2) {
    CompletionItemTag2.Deprecated = 1;
  })(CompletionItemTag || (CompletionItemTag = {}));
  var CompletionItem;
  (function(CompletionItem2) {
    function create(label) {
      return {label};
    }
    CompletionItem2.create = create;
  })(CompletionItem || (CompletionItem = {}));
  var CompletionList;
  (function(CompletionList2) {
    function create(items, isIncomplete) {
      return {items: items ? items : [], isIncomplete: !!isIncomplete};
    }
    CompletionList2.create = create;
  })(CompletionList || (CompletionList = {}));
  var MarkedString;
  (function(MarkedString2) {
    function fromPlainText(plainText) {
      return plainText.replace(/[\\`*_{}[\]()#+\-.!]/g, "\\$&");
    }
    MarkedString2.fromPlainText = fromPlainText;
    function is(value) {
      var candidate = value;
      return Is.string(candidate) || Is.objectLiteral(candidate) && Is.string(candidate.language) && Is.string(candidate.value);
    }
    MarkedString2.is = is;
  })(MarkedString || (MarkedString = {}));
  var Hover;
  (function(Hover2) {
    function is(value) {
      var candidate = value;
      return !!candidate && Is.objectLiteral(candidate) && (MarkupContent.is(candidate.contents) || MarkedString.is(candidate.contents) || Is.typedArray(candidate.contents, MarkedString.is)) && (value.range === void 0 || Range2.is(value.range));
    }
    Hover2.is = is;
  })(Hover || (Hover = {}));
  var ParameterInformation;
  (function(ParameterInformation2) {
    function create(label, documentation) {
      return documentation ? {label, documentation} : {label};
    }
    ParameterInformation2.create = create;
  })(ParameterInformation || (ParameterInformation = {}));
  var SignatureInformation;
  (function(SignatureInformation2) {
    function create(label, documentation) {
      var parameters = [];
      for (var _i = 2; _i < arguments.length; _i++) {
        parameters[_i - 2] = arguments[_i];
      }
      var result = {label};
      if (Is.defined(documentation)) {
        result.documentation = documentation;
      }
      if (Is.defined(parameters)) {
        result.parameters = parameters;
      } else {
        result.parameters = [];
      }
      return result;
    }
    SignatureInformation2.create = create;
  })(SignatureInformation || (SignatureInformation = {}));
  var DocumentHighlightKind;
  (function(DocumentHighlightKind2) {
    DocumentHighlightKind2.Text = 1;
    DocumentHighlightKind2.Read = 2;
    DocumentHighlightKind2.Write = 3;
  })(DocumentHighlightKind || (DocumentHighlightKind = {}));
  var DocumentHighlight;
  (function(DocumentHighlight2) {
    function create(range, kind) {
      var result = {range};
      if (Is.number(kind)) {
        result.kind = kind;
      }
      return result;
    }
    DocumentHighlight2.create = create;
  })(DocumentHighlight || (DocumentHighlight = {}));
  var SymbolKind;
  (function(SymbolKind2) {
    SymbolKind2.File = 1;
    SymbolKind2.Module = 2;
    SymbolKind2.Namespace = 3;
    SymbolKind2.Package = 4;
    SymbolKind2.Class = 5;
    SymbolKind2.Method = 6;
    SymbolKind2.Property = 7;
    SymbolKind2.Field = 8;
    SymbolKind2.Constructor = 9;
    SymbolKind2.Enum = 10;
    SymbolKind2.Interface = 11;
    SymbolKind2.Function = 12;
    SymbolKind2.Variable = 13;
    SymbolKind2.Constant = 14;
    SymbolKind2.String = 15;
    SymbolKind2.Number = 16;
    SymbolKind2.Boolean = 17;
    SymbolKind2.Array = 18;
    SymbolKind2.Object = 19;
    SymbolKind2.Key = 20;
    SymbolKind2.Null = 21;
    SymbolKind2.EnumMember = 22;
    SymbolKind2.Struct = 23;
    SymbolKind2.Event = 24;
    SymbolKind2.Operator = 25;
    SymbolKind2.TypeParameter = 26;
  })(SymbolKind || (SymbolKind = {}));
  var SymbolTag;
  (function(SymbolTag2) {
    SymbolTag2.Deprecated = 1;
  })(SymbolTag || (SymbolTag = {}));
  var SymbolInformation;
  (function(SymbolInformation2) {
    function create(name, kind, range, uri, containerName) {
      var result = {
        name,
        kind,
        location: {uri, range}
      };
      if (containerName) {
        result.containerName = containerName;
      }
      return result;
    }
    SymbolInformation2.create = create;
  })(SymbolInformation || (SymbolInformation = {}));
  var DocumentSymbol;
  (function(DocumentSymbol2) {
    function create(name, detail, kind, range, selectionRange, children) {
      var result = {
        name,
        detail,
        kind,
        range,
        selectionRange
      };
      if (children !== void 0) {
        result.children = children;
      }
      return result;
    }
    DocumentSymbol2.create = create;
    function is(value) {
      var candidate = value;
      return candidate && Is.string(candidate.name) && Is.number(candidate.kind) && Range2.is(candidate.range) && Range2.is(candidate.selectionRange) && (candidate.detail === void 0 || Is.string(candidate.detail)) && (candidate.deprecated === void 0 || Is.boolean(candidate.deprecated)) && (candidate.children === void 0 || Array.isArray(candidate.children));
    }
    DocumentSymbol2.is = is;
  })(DocumentSymbol || (DocumentSymbol = {}));
  var CodeActionKind2;
  (function(CodeActionKind3) {
    CodeActionKind3.Empty = "";
    CodeActionKind3.QuickFix = "quickfix";
    CodeActionKind3.Refactor = "refactor";
    CodeActionKind3.RefactorExtract = "refactor.extract";
    CodeActionKind3.RefactorInline = "refactor.inline";
    CodeActionKind3.RefactorRewrite = "refactor.rewrite";
    CodeActionKind3.Source = "source";
    CodeActionKind3.SourceOrganizeImports = "source.organizeImports";
    CodeActionKind3.SourceFixAll = "source.fixAll";
  })(CodeActionKind2 || (CodeActionKind2 = {}));
  var CodeActionContext;
  (function(CodeActionContext2) {
    function create(diagnostics, only) {
      var result = {diagnostics};
      if (only !== void 0 && only !== null) {
        result.only = only;
      }
      return result;
    }
    CodeActionContext2.create = create;
    function is(value) {
      var candidate = value;
      return Is.defined(candidate) && Is.typedArray(candidate.diagnostics, Diagnostic.is) && (candidate.only === void 0 || Is.typedArray(candidate.only, Is.string));
    }
    CodeActionContext2.is = is;
  })(CodeActionContext || (CodeActionContext = {}));
  var CodeAction3;
  (function(CodeAction4) {
    function create(title, commandOrEdit, kind) {
      var result = {title};
      if (Command2.is(commandOrEdit)) {
        result.command = commandOrEdit;
      } else {
        result.edit = commandOrEdit;
      }
      if (kind !== void 0) {
        result.kind = kind;
      }
      return result;
    }
    CodeAction4.create = create;
    function is(value) {
      var candidate = value;
      return candidate && Is.string(candidate.title) && (candidate.diagnostics === void 0 || Is.typedArray(candidate.diagnostics, Diagnostic.is)) && (candidate.kind === void 0 || Is.string(candidate.kind)) && (candidate.edit !== void 0 || candidate.command !== void 0) && (candidate.command === void 0 || Command2.is(candidate.command)) && (candidate.isPreferred === void 0 || Is.boolean(candidate.isPreferred)) && (candidate.edit === void 0 || WorkspaceEdit2.is(candidate.edit));
    }
    CodeAction4.is = is;
  })(CodeAction3 || (CodeAction3 = {}));
  var CodeLens;
  (function(CodeLens2) {
    function create(range, data) {
      var result = {range};
      if (Is.defined(data)) {
        result.data = data;
      }
      return result;
    }
    CodeLens2.create = create;
    function is(value) {
      var candidate = value;
      return Is.defined(candidate) && Range2.is(candidate.range) && (Is.undefined(candidate.command) || Command2.is(candidate.command));
    }
    CodeLens2.is = is;
  })(CodeLens || (CodeLens = {}));
  var FormattingOptions;
  (function(FormattingOptions2) {
    function create(tabSize, insertSpaces) {
      return {tabSize, insertSpaces};
    }
    FormattingOptions2.create = create;
    function is(value) {
      var candidate = value;
      return Is.defined(candidate) && Is.number(candidate.tabSize) && Is.boolean(candidate.insertSpaces);
    }
    FormattingOptions2.is = is;
  })(FormattingOptions || (FormattingOptions = {}));
  var DocumentLink;
  (function(DocumentLink2) {
    function create(range, target, data) {
      return {range, target, data};
    }
    DocumentLink2.create = create;
    function is(value) {
      var candidate = value;
      return Is.defined(candidate) && Range2.is(candidate.range) && (Is.undefined(candidate.target) || Is.string(candidate.target));
    }
    DocumentLink2.is = is;
  })(DocumentLink || (DocumentLink = {}));
  var SelectionRange;
  (function(SelectionRange2) {
    function create(range, parent) {
      return {range, parent};
    }
    SelectionRange2.create = create;
    function is(value) {
      var candidate = value;
      return candidate !== void 0 && Range2.is(candidate.range) && (candidate.parent === void 0 || SelectionRange2.is(candidate.parent));
    }
    SelectionRange2.is = is;
  })(SelectionRange || (SelectionRange = {}));
  var EOL = ["\n", "\r\n", "\r"];
  var TextDocument;
  (function(TextDocument2) {
    function create(uri, languageId, version, content) {
      return new FullTextDocument(uri, languageId, version, content);
    }
    TextDocument2.create = create;
    function is(value) {
      var candidate = value;
      return Is.defined(candidate) && Is.string(candidate.uri) && (Is.undefined(candidate.languageId) || Is.string(candidate.languageId)) && Is.number(candidate.lineCount) && Is.func(candidate.getText) && Is.func(candidate.positionAt) && Is.func(candidate.offsetAt) ? true : false;
    }
    TextDocument2.is = is;
    function applyEdits(document2, edits) {
      var text = document2.getText();
      var sortedEdits = mergeSort(edits, function(a, b) {
        var diff = a.range.start.line - b.range.start.line;
        if (diff === 0) {
          return a.range.start.character - b.range.start.character;
        }
        return diff;
      });
      var lastModifiedOffset = text.length;
      for (var i = sortedEdits.length - 1; i >= 0; i--) {
        var e = sortedEdits[i];
        var startOffset = document2.offsetAt(e.range.start);
        var endOffset = document2.offsetAt(e.range.end);
        if (endOffset <= lastModifiedOffset) {
          text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);
        } else {
          throw new Error("Overlapping edit");
        }
        lastModifiedOffset = startOffset;
      }
      return text;
    }
    TextDocument2.applyEdits = applyEdits;
    function mergeSort(data, compare) {
      if (data.length <= 1) {
        return data;
      }
      var p = data.length / 2 | 0;
      var left = data.slice(0, p);
      var right = data.slice(p);
      mergeSort(left, compare);
      mergeSort(right, compare);
      var leftIdx = 0;
      var rightIdx = 0;
      var i = 0;
      while (leftIdx < left.length && rightIdx < right.length) {
        var ret = compare(left[leftIdx], right[rightIdx]);
        if (ret <= 0) {
          data[i++] = left[leftIdx++];
        } else {
          data[i++] = right[rightIdx++];
        }
      }
      while (leftIdx < left.length) {
        data[i++] = left[leftIdx++];
      }
      while (rightIdx < right.length) {
        data[i++] = right[rightIdx++];
      }
      return data;
    }
  })(TextDocument || (TextDocument = {}));
  var FullTextDocument = function() {
    function FullTextDocument2(uri, languageId, version, content) {
      this._uri = uri;
      this._languageId = languageId;
      this._version = version;
      this._content = content;
      this._lineOffsets = void 0;
    }
    Object.defineProperty(FullTextDocument2.prototype, "uri", {
      get: function() {
        return this._uri;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(FullTextDocument2.prototype, "languageId", {
      get: function() {
        return this._languageId;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(FullTextDocument2.prototype, "version", {
      get: function() {
        return this._version;
      },
      enumerable: true,
      configurable: true
    });
    FullTextDocument2.prototype.getText = function(range) {
      if (range) {
        var start = this.offsetAt(range.start);
        var end = this.offsetAt(range.end);
        return this._content.substring(start, end);
      }
      return this._content;
    };
    FullTextDocument2.prototype.update = function(event, version) {
      this._content = event.text;
      this._version = version;
      this._lineOffsets = void 0;
    };
    FullTextDocument2.prototype.getLineOffsets = function() {
      if (this._lineOffsets === void 0) {
        var lineOffsets = [];
        var text = this._content;
        var isLineStart = true;
        for (var i = 0; i < text.length; i++) {
          if (isLineStart) {
            lineOffsets.push(i);
            isLineStart = false;
          }
          var ch = text.charAt(i);
          isLineStart = ch === "\r" || ch === "\n";
          if (ch === "\r" && i + 1 < text.length && text.charAt(i + 1) === "\n") {
            i++;
          }
        }
        if (isLineStart && text.length > 0) {
          lineOffsets.push(text.length);
        }
        this._lineOffsets = lineOffsets;
      }
      return this._lineOffsets;
    };
    FullTextDocument2.prototype.positionAt = function(offset) {
      offset = Math.max(Math.min(offset, this._content.length), 0);
      var lineOffsets = this.getLineOffsets();
      var low = 0, high = lineOffsets.length;
      if (high === 0) {
        return Position2.create(0, offset);
      }
      while (low < high) {
        var mid = Math.floor((low + high) / 2);
        if (lineOffsets[mid] > offset) {
          high = mid;
        } else {
          low = mid + 1;
        }
      }
      var line = low - 1;
      return Position2.create(line, offset - lineOffsets[line]);
    };
    FullTextDocument2.prototype.offsetAt = function(position) {
      var lineOffsets = this.getLineOffsets();
      if (position.line >= lineOffsets.length) {
        return this._content.length;
      } else if (position.line < 0) {
        return 0;
      }
      var lineOffset = lineOffsets[position.line];
      var nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;
      return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
    };
    Object.defineProperty(FullTextDocument2.prototype, "lineCount", {
      get: function() {
        return this.getLineOffsets().length;
      },
      enumerable: true,
      configurable: true
    });
    return FullTextDocument2;
  }();
  var Is;
  (function(Is2) {
    var toString = Object.prototype.toString;
    function defined(value) {
      return typeof value !== "undefined";
    }
    Is2.defined = defined;
    function undefined2(value) {
      return typeof value === "undefined";
    }
    Is2.undefined = undefined2;
    function boolean(value) {
      return value === true || value === false;
    }
    Is2.boolean = boolean;
    function string(value) {
      return toString.call(value) === "[object String]";
    }
    Is2.string = string;
    function number(value) {
      return toString.call(value) === "[object Number]";
    }
    Is2.number = number;
    function func(value) {
      return toString.call(value) === "[object Function]";
    }
    Is2.func = func;
    function objectLiteral(value) {
      return value !== null && typeof value === "object";
    }
    Is2.objectLiteral = objectLiteral;
    function typedArray(value, check) {
      return Array.isArray(value) && value.every(check);
    }
    Is2.typedArray = typedArray;
  })(Is || (Is = {}));
});

// node_modules/vscode-languageserver-protocol/lib/utils/is.js
var require_is2 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  function boolean(value) {
    return value === true || value === false;
  }
  exports2.boolean = boolean;
  function string(value) {
    return typeof value === "string" || value instanceof String;
  }
  exports2.string = string;
  function number(value) {
    return typeof value === "number" || value instanceof Number;
  }
  exports2.number = number;
  function error(value) {
    return value instanceof Error;
  }
  exports2.error = error;
  function func(value) {
    return typeof value === "function";
  }
  exports2.func = func;
  function array(value) {
    return Array.isArray(value);
  }
  exports2.array = array;
  function stringArray(value) {
    return array(value) && value.every((elem) => string(elem));
  }
  exports2.stringArray = stringArray;
  function typedArray(value, check) {
    return Array.isArray(value) && value.every(check);
  }
  exports2.typedArray = typedArray;
  function objectLiteral(value) {
    return value !== null && typeof value === "object";
  }
  exports2.objectLiteral = objectLiteral;
});

// node_modules/vscode-languageserver-protocol/lib/messages.js
var require_messages2 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var vscode_jsonrpc_1 = require_main();
  var ProtocolRequestType0 = class extends vscode_jsonrpc_1.RequestType0 {
    constructor(method) {
      super(method);
    }
  };
  exports2.ProtocolRequestType0 = ProtocolRequestType0;
  var ProtocolRequestType = class extends vscode_jsonrpc_1.RequestType {
    constructor(method) {
      super(method);
    }
  };
  exports2.ProtocolRequestType = ProtocolRequestType;
  var ProtocolNotificationType = class extends vscode_jsonrpc_1.NotificationType {
    constructor(method) {
      super(method);
    }
  };
  exports2.ProtocolNotificationType = ProtocolNotificationType;
  var ProtocolNotificationType0 = class extends vscode_jsonrpc_1.NotificationType0 {
    constructor(method) {
      super(method);
    }
  };
  exports2.ProtocolNotificationType0 = ProtocolNotificationType0;
});

// node_modules/vscode-languageserver-protocol/lib/protocol.implementation.js
var require_protocol_implementation = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var vscode_jsonrpc_1 = require_main();
  var messages_1 = require_messages2();
  var ImplementationRequest;
  (function(ImplementationRequest2) {
    ImplementationRequest2.method = "textDocument/implementation";
    ImplementationRequest2.type = new messages_1.ProtocolRequestType(ImplementationRequest2.method);
    ImplementationRequest2.resultType = new vscode_jsonrpc_1.ProgressType();
  })(ImplementationRequest = exports2.ImplementationRequest || (exports2.ImplementationRequest = {}));
});

// node_modules/vscode-languageserver-protocol/lib/protocol.typeDefinition.js
var require_protocol_typeDefinition = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var vscode_jsonrpc_1 = require_main();
  var messages_1 = require_messages2();
  var TypeDefinitionRequest;
  (function(TypeDefinitionRequest2) {
    TypeDefinitionRequest2.method = "textDocument/typeDefinition";
    TypeDefinitionRequest2.type = new messages_1.ProtocolRequestType(TypeDefinitionRequest2.method);
    TypeDefinitionRequest2.resultType = new vscode_jsonrpc_1.ProgressType();
  })(TypeDefinitionRequest = exports2.TypeDefinitionRequest || (exports2.TypeDefinitionRequest = {}));
});

// node_modules/vscode-languageserver-protocol/lib/protocol.workspaceFolders.js
var require_protocol_workspaceFolders = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var messages_1 = require_messages2();
  var WorkspaceFoldersRequest;
  (function(WorkspaceFoldersRequest2) {
    WorkspaceFoldersRequest2.type = new messages_1.ProtocolRequestType0("workspace/workspaceFolders");
  })(WorkspaceFoldersRequest = exports2.WorkspaceFoldersRequest || (exports2.WorkspaceFoldersRequest = {}));
  var DidChangeWorkspaceFoldersNotification;
  (function(DidChangeWorkspaceFoldersNotification2) {
    DidChangeWorkspaceFoldersNotification2.type = new messages_1.ProtocolNotificationType("workspace/didChangeWorkspaceFolders");
  })(DidChangeWorkspaceFoldersNotification = exports2.DidChangeWorkspaceFoldersNotification || (exports2.DidChangeWorkspaceFoldersNotification = {}));
});

// node_modules/vscode-languageserver-protocol/lib/protocol.configuration.js
var require_protocol_configuration = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var messages_1 = require_messages2();
  var ConfigurationRequest;
  (function(ConfigurationRequest2) {
    ConfigurationRequest2.type = new messages_1.ProtocolRequestType("workspace/configuration");
  })(ConfigurationRequest = exports2.ConfigurationRequest || (exports2.ConfigurationRequest = {}));
});

// node_modules/vscode-languageserver-protocol/lib/protocol.colorProvider.js
var require_protocol_colorProvider = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var vscode_jsonrpc_1 = require_main();
  var messages_1 = require_messages2();
  var DocumentColorRequest;
  (function(DocumentColorRequest2) {
    DocumentColorRequest2.method = "textDocument/documentColor";
    DocumentColorRequest2.type = new messages_1.ProtocolRequestType(DocumentColorRequest2.method);
    DocumentColorRequest2.resultType = new vscode_jsonrpc_1.ProgressType();
  })(DocumentColorRequest = exports2.DocumentColorRequest || (exports2.DocumentColorRequest = {}));
  var ColorPresentationRequest;
  (function(ColorPresentationRequest2) {
    ColorPresentationRequest2.type = new messages_1.ProtocolRequestType("textDocument/colorPresentation");
  })(ColorPresentationRequest = exports2.ColorPresentationRequest || (exports2.ColorPresentationRequest = {}));
});

// node_modules/vscode-languageserver-protocol/lib/protocol.foldingRange.js
var require_protocol_foldingRange = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var vscode_jsonrpc_1 = require_main();
  var messages_1 = require_messages2();
  var FoldingRangeKind;
  (function(FoldingRangeKind2) {
    FoldingRangeKind2["Comment"] = "comment";
    FoldingRangeKind2["Imports"] = "imports";
    FoldingRangeKind2["Region"] = "region";
  })(FoldingRangeKind = exports2.FoldingRangeKind || (exports2.FoldingRangeKind = {}));
  var FoldingRangeRequest;
  (function(FoldingRangeRequest2) {
    FoldingRangeRequest2.method = "textDocument/foldingRange";
    FoldingRangeRequest2.type = new messages_1.ProtocolRequestType(FoldingRangeRequest2.method);
    FoldingRangeRequest2.resultType = new vscode_jsonrpc_1.ProgressType();
  })(FoldingRangeRequest = exports2.FoldingRangeRequest || (exports2.FoldingRangeRequest = {}));
});

// node_modules/vscode-languageserver-protocol/lib/protocol.declaration.js
var require_protocol_declaration = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var vscode_jsonrpc_1 = require_main();
  var messages_1 = require_messages2();
  var DeclarationRequest;
  (function(DeclarationRequest2) {
    DeclarationRequest2.method = "textDocument/declaration";
    DeclarationRequest2.type = new messages_1.ProtocolRequestType(DeclarationRequest2.method);
    DeclarationRequest2.resultType = new vscode_jsonrpc_1.ProgressType();
  })(DeclarationRequest = exports2.DeclarationRequest || (exports2.DeclarationRequest = {}));
});

// node_modules/vscode-languageserver-protocol/lib/protocol.selectionRange.js
var require_protocol_selectionRange = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var vscode_jsonrpc_1 = require_main();
  var messages_1 = require_messages2();
  var SelectionRangeRequest;
  (function(SelectionRangeRequest2) {
    SelectionRangeRequest2.method = "textDocument/selectionRange";
    SelectionRangeRequest2.type = new messages_1.ProtocolRequestType(SelectionRangeRequest2.method);
    SelectionRangeRequest2.resultType = new vscode_jsonrpc_1.ProgressType();
  })(SelectionRangeRequest = exports2.SelectionRangeRequest || (exports2.SelectionRangeRequest = {}));
});

// node_modules/vscode-languageserver-protocol/lib/protocol.progress.js
var require_protocol_progress = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var vscode_jsonrpc_1 = require_main();
  var messages_1 = require_messages2();
  var WorkDoneProgress;
  (function(WorkDoneProgress2) {
    WorkDoneProgress2.type = new vscode_jsonrpc_1.ProgressType();
  })(WorkDoneProgress = exports2.WorkDoneProgress || (exports2.WorkDoneProgress = {}));
  var WorkDoneProgressCreateRequest;
  (function(WorkDoneProgressCreateRequest2) {
    WorkDoneProgressCreateRequest2.type = new messages_1.ProtocolRequestType("window/workDoneProgress/create");
  })(WorkDoneProgressCreateRequest = exports2.WorkDoneProgressCreateRequest || (exports2.WorkDoneProgressCreateRequest = {}));
  var WorkDoneProgressCancelNotification;
  (function(WorkDoneProgressCancelNotification2) {
    WorkDoneProgressCancelNotification2.type = new messages_1.ProtocolNotificationType("window/workDoneProgress/cancel");
  })(WorkDoneProgressCancelNotification = exports2.WorkDoneProgressCancelNotification || (exports2.WorkDoneProgressCancelNotification = {}));
});

// node_modules/vscode-languageserver-protocol/lib/protocol.js
var require_protocol = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var Is = require_is2();
  var vscode_jsonrpc_1 = require_main();
  var messages_1 = require_messages2();
  var protocol_implementation_1 = require_protocol_implementation();
  exports2.ImplementationRequest = protocol_implementation_1.ImplementationRequest;
  var protocol_typeDefinition_1 = require_protocol_typeDefinition();
  exports2.TypeDefinitionRequest = protocol_typeDefinition_1.TypeDefinitionRequest;
  var protocol_workspaceFolders_1 = require_protocol_workspaceFolders();
  exports2.WorkspaceFoldersRequest = protocol_workspaceFolders_1.WorkspaceFoldersRequest;
  exports2.DidChangeWorkspaceFoldersNotification = protocol_workspaceFolders_1.DidChangeWorkspaceFoldersNotification;
  var protocol_configuration_1 = require_protocol_configuration();
  exports2.ConfigurationRequest = protocol_configuration_1.ConfigurationRequest;
  var protocol_colorProvider_1 = require_protocol_colorProvider();
  exports2.DocumentColorRequest = protocol_colorProvider_1.DocumentColorRequest;
  exports2.ColorPresentationRequest = protocol_colorProvider_1.ColorPresentationRequest;
  var protocol_foldingRange_1 = require_protocol_foldingRange();
  exports2.FoldingRangeRequest = protocol_foldingRange_1.FoldingRangeRequest;
  var protocol_declaration_1 = require_protocol_declaration();
  exports2.DeclarationRequest = protocol_declaration_1.DeclarationRequest;
  var protocol_selectionRange_1 = require_protocol_selectionRange();
  exports2.SelectionRangeRequest = protocol_selectionRange_1.SelectionRangeRequest;
  var protocol_progress_1 = require_protocol_progress();
  exports2.WorkDoneProgress = protocol_progress_1.WorkDoneProgress;
  exports2.WorkDoneProgressCreateRequest = protocol_progress_1.WorkDoneProgressCreateRequest;
  exports2.WorkDoneProgressCancelNotification = protocol_progress_1.WorkDoneProgressCancelNotification;
  var DocumentFilter;
  (function(DocumentFilter2) {
    function is(value) {
      const candidate = value;
      return Is.string(candidate.language) || Is.string(candidate.scheme) || Is.string(candidate.pattern);
    }
    DocumentFilter2.is = is;
  })(DocumentFilter = exports2.DocumentFilter || (exports2.DocumentFilter = {}));
  var DocumentSelector;
  (function(DocumentSelector2) {
    function is(value) {
      if (!Array.isArray(value)) {
        return false;
      }
      for (let elem of value) {
        if (!Is.string(elem) && !DocumentFilter.is(elem)) {
          return false;
        }
      }
      return true;
    }
    DocumentSelector2.is = is;
  })(DocumentSelector = exports2.DocumentSelector || (exports2.DocumentSelector = {}));
  var RegistrationRequest;
  (function(RegistrationRequest2) {
    RegistrationRequest2.type = new messages_1.ProtocolRequestType("client/registerCapability");
  })(RegistrationRequest = exports2.RegistrationRequest || (exports2.RegistrationRequest = {}));
  var UnregistrationRequest;
  (function(UnregistrationRequest2) {
    UnregistrationRequest2.type = new messages_1.ProtocolRequestType("client/unregisterCapability");
  })(UnregistrationRequest = exports2.UnregistrationRequest || (exports2.UnregistrationRequest = {}));
  var ResourceOperationKind;
  (function(ResourceOperationKind2) {
    ResourceOperationKind2.Create = "create";
    ResourceOperationKind2.Rename = "rename";
    ResourceOperationKind2.Delete = "delete";
  })(ResourceOperationKind = exports2.ResourceOperationKind || (exports2.ResourceOperationKind = {}));
  var FailureHandlingKind;
  (function(FailureHandlingKind2) {
    FailureHandlingKind2.Abort = "abort";
    FailureHandlingKind2.Transactional = "transactional";
    FailureHandlingKind2.TextOnlyTransactional = "textOnlyTransactional";
    FailureHandlingKind2.Undo = "undo";
  })(FailureHandlingKind = exports2.FailureHandlingKind || (exports2.FailureHandlingKind = {}));
  var StaticRegistrationOptions;
  (function(StaticRegistrationOptions2) {
    function hasId(value) {
      const candidate = value;
      return candidate && Is.string(candidate.id) && candidate.id.length > 0;
    }
    StaticRegistrationOptions2.hasId = hasId;
  })(StaticRegistrationOptions = exports2.StaticRegistrationOptions || (exports2.StaticRegistrationOptions = {}));
  var TextDocumentRegistrationOptions;
  (function(TextDocumentRegistrationOptions2) {
    function is(value) {
      const candidate = value;
      return candidate && (candidate.documentSelector === null || DocumentSelector.is(candidate.documentSelector));
    }
    TextDocumentRegistrationOptions2.is = is;
  })(TextDocumentRegistrationOptions = exports2.TextDocumentRegistrationOptions || (exports2.TextDocumentRegistrationOptions = {}));
  var WorkDoneProgressOptions;
  (function(WorkDoneProgressOptions2) {
    function is(value) {
      const candidate = value;
      return Is.objectLiteral(candidate) && (candidate.workDoneProgress === void 0 || Is.boolean(candidate.workDoneProgress));
    }
    WorkDoneProgressOptions2.is = is;
    function hasWorkDoneProgress(value) {
      const candidate = value;
      return candidate && Is.boolean(candidate.workDoneProgress);
    }
    WorkDoneProgressOptions2.hasWorkDoneProgress = hasWorkDoneProgress;
  })(WorkDoneProgressOptions = exports2.WorkDoneProgressOptions || (exports2.WorkDoneProgressOptions = {}));
  var InitializeRequest;
  (function(InitializeRequest2) {
    InitializeRequest2.type = new messages_1.ProtocolRequestType("initialize");
  })(InitializeRequest = exports2.InitializeRequest || (exports2.InitializeRequest = {}));
  var InitializeError;
  (function(InitializeError2) {
    InitializeError2.unknownProtocolVersion = 1;
  })(InitializeError = exports2.InitializeError || (exports2.InitializeError = {}));
  var InitializedNotification;
  (function(InitializedNotification2) {
    InitializedNotification2.type = new messages_1.ProtocolNotificationType("initialized");
  })(InitializedNotification = exports2.InitializedNotification || (exports2.InitializedNotification = {}));
  var ShutdownRequest;
  (function(ShutdownRequest2) {
    ShutdownRequest2.type = new messages_1.ProtocolRequestType0("shutdown");
  })(ShutdownRequest = exports2.ShutdownRequest || (exports2.ShutdownRequest = {}));
  var ExitNotification;
  (function(ExitNotification2) {
    ExitNotification2.type = new messages_1.ProtocolNotificationType0("exit");
  })(ExitNotification = exports2.ExitNotification || (exports2.ExitNotification = {}));
  var DidChangeConfigurationNotification;
  (function(DidChangeConfigurationNotification2) {
    DidChangeConfigurationNotification2.type = new messages_1.ProtocolNotificationType("workspace/didChangeConfiguration");
  })(DidChangeConfigurationNotification = exports2.DidChangeConfigurationNotification || (exports2.DidChangeConfigurationNotification = {}));
  var MessageType;
  (function(MessageType2) {
    MessageType2.Error = 1;
    MessageType2.Warning = 2;
    MessageType2.Info = 3;
    MessageType2.Log = 4;
  })(MessageType = exports2.MessageType || (exports2.MessageType = {}));
  var ShowMessageNotification;
  (function(ShowMessageNotification2) {
    ShowMessageNotification2.type = new messages_1.ProtocolNotificationType("window/showMessage");
  })(ShowMessageNotification = exports2.ShowMessageNotification || (exports2.ShowMessageNotification = {}));
  var ShowMessageRequest;
  (function(ShowMessageRequest2) {
    ShowMessageRequest2.type = new messages_1.ProtocolRequestType("window/showMessageRequest");
  })(ShowMessageRequest = exports2.ShowMessageRequest || (exports2.ShowMessageRequest = {}));
  var LogMessageNotification;
  (function(LogMessageNotification2) {
    LogMessageNotification2.type = new messages_1.ProtocolNotificationType("window/logMessage");
  })(LogMessageNotification = exports2.LogMessageNotification || (exports2.LogMessageNotification = {}));
  var TelemetryEventNotification;
  (function(TelemetryEventNotification2) {
    TelemetryEventNotification2.type = new messages_1.ProtocolNotificationType("telemetry/event");
  })(TelemetryEventNotification = exports2.TelemetryEventNotification || (exports2.TelemetryEventNotification = {}));
  var TextDocumentSyncKind;
  (function(TextDocumentSyncKind2) {
    TextDocumentSyncKind2.None = 0;
    TextDocumentSyncKind2.Full = 1;
    TextDocumentSyncKind2.Incremental = 2;
  })(TextDocumentSyncKind = exports2.TextDocumentSyncKind || (exports2.TextDocumentSyncKind = {}));
  var DidOpenTextDocumentNotification;
  (function(DidOpenTextDocumentNotification2) {
    DidOpenTextDocumentNotification2.method = "textDocument/didOpen";
    DidOpenTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidOpenTextDocumentNotification2.method);
  })(DidOpenTextDocumentNotification = exports2.DidOpenTextDocumentNotification || (exports2.DidOpenTextDocumentNotification = {}));
  var DidChangeTextDocumentNotification;
  (function(DidChangeTextDocumentNotification2) {
    DidChangeTextDocumentNotification2.method = "textDocument/didChange";
    DidChangeTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidChangeTextDocumentNotification2.method);
  })(DidChangeTextDocumentNotification = exports2.DidChangeTextDocumentNotification || (exports2.DidChangeTextDocumentNotification = {}));
  var DidCloseTextDocumentNotification;
  (function(DidCloseTextDocumentNotification2) {
    DidCloseTextDocumentNotification2.method = "textDocument/didClose";
    DidCloseTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidCloseTextDocumentNotification2.method);
  })(DidCloseTextDocumentNotification = exports2.DidCloseTextDocumentNotification || (exports2.DidCloseTextDocumentNotification = {}));
  var DidSaveTextDocumentNotification;
  (function(DidSaveTextDocumentNotification2) {
    DidSaveTextDocumentNotification2.method = "textDocument/didSave";
    DidSaveTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidSaveTextDocumentNotification2.method);
  })(DidSaveTextDocumentNotification = exports2.DidSaveTextDocumentNotification || (exports2.DidSaveTextDocumentNotification = {}));
  var TextDocumentSaveReason;
  (function(TextDocumentSaveReason2) {
    TextDocumentSaveReason2.Manual = 1;
    TextDocumentSaveReason2.AfterDelay = 2;
    TextDocumentSaveReason2.FocusOut = 3;
  })(TextDocumentSaveReason = exports2.TextDocumentSaveReason || (exports2.TextDocumentSaveReason = {}));
  var WillSaveTextDocumentNotification;
  (function(WillSaveTextDocumentNotification2) {
    WillSaveTextDocumentNotification2.method = "textDocument/willSave";
    WillSaveTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(WillSaveTextDocumentNotification2.method);
  })(WillSaveTextDocumentNotification = exports2.WillSaveTextDocumentNotification || (exports2.WillSaveTextDocumentNotification = {}));
  var WillSaveTextDocumentWaitUntilRequest;
  (function(WillSaveTextDocumentWaitUntilRequest2) {
    WillSaveTextDocumentWaitUntilRequest2.method = "textDocument/willSaveWaitUntil";
    WillSaveTextDocumentWaitUntilRequest2.type = new messages_1.ProtocolRequestType(WillSaveTextDocumentWaitUntilRequest2.method);
  })(WillSaveTextDocumentWaitUntilRequest = exports2.WillSaveTextDocumentWaitUntilRequest || (exports2.WillSaveTextDocumentWaitUntilRequest = {}));
  var DidChangeWatchedFilesNotification;
  (function(DidChangeWatchedFilesNotification2) {
    DidChangeWatchedFilesNotification2.type = new messages_1.ProtocolNotificationType("workspace/didChangeWatchedFiles");
  })(DidChangeWatchedFilesNotification = exports2.DidChangeWatchedFilesNotification || (exports2.DidChangeWatchedFilesNotification = {}));
  var FileChangeType;
  (function(FileChangeType2) {
    FileChangeType2.Created = 1;
    FileChangeType2.Changed = 2;
    FileChangeType2.Deleted = 3;
  })(FileChangeType = exports2.FileChangeType || (exports2.FileChangeType = {}));
  var WatchKind;
  (function(WatchKind2) {
    WatchKind2.Create = 1;
    WatchKind2.Change = 2;
    WatchKind2.Delete = 4;
  })(WatchKind = exports2.WatchKind || (exports2.WatchKind = {}));
  var PublishDiagnosticsNotification;
  (function(PublishDiagnosticsNotification2) {
    PublishDiagnosticsNotification2.type = new messages_1.ProtocolNotificationType("textDocument/publishDiagnostics");
  })(PublishDiagnosticsNotification = exports2.PublishDiagnosticsNotification || (exports2.PublishDiagnosticsNotification = {}));
  var CompletionTriggerKind;
  (function(CompletionTriggerKind2) {
    CompletionTriggerKind2.Invoked = 1;
    CompletionTriggerKind2.TriggerCharacter = 2;
    CompletionTriggerKind2.TriggerForIncompleteCompletions = 3;
  })(CompletionTriggerKind = exports2.CompletionTriggerKind || (exports2.CompletionTriggerKind = {}));
  var CompletionRequest;
  (function(CompletionRequest2) {
    CompletionRequest2.method = "textDocument/completion";
    CompletionRequest2.type = new messages_1.ProtocolRequestType(CompletionRequest2.method);
    CompletionRequest2.resultType = new vscode_jsonrpc_1.ProgressType();
  })(CompletionRequest = exports2.CompletionRequest || (exports2.CompletionRequest = {}));
  var CompletionResolveRequest;
  (function(CompletionResolveRequest2) {
    CompletionResolveRequest2.method = "completionItem/resolve";
    CompletionResolveRequest2.type = new messages_1.ProtocolRequestType(CompletionResolveRequest2.method);
  })(CompletionResolveRequest = exports2.CompletionResolveRequest || (exports2.CompletionResolveRequest = {}));
  var HoverRequest;
  (function(HoverRequest2) {
    HoverRequest2.method = "textDocument/hover";
    HoverRequest2.type = new messages_1.ProtocolRequestType(HoverRequest2.method);
  })(HoverRequest = exports2.HoverRequest || (exports2.HoverRequest = {}));
  var SignatureHelpTriggerKind;
  (function(SignatureHelpTriggerKind2) {
    SignatureHelpTriggerKind2.Invoked = 1;
    SignatureHelpTriggerKind2.TriggerCharacter = 2;
    SignatureHelpTriggerKind2.ContentChange = 3;
  })(SignatureHelpTriggerKind = exports2.SignatureHelpTriggerKind || (exports2.SignatureHelpTriggerKind = {}));
  var SignatureHelpRequest;
  (function(SignatureHelpRequest2) {
    SignatureHelpRequest2.method = "textDocument/signatureHelp";
    SignatureHelpRequest2.type = new messages_1.ProtocolRequestType(SignatureHelpRequest2.method);
  })(SignatureHelpRequest = exports2.SignatureHelpRequest || (exports2.SignatureHelpRequest = {}));
  var DefinitionRequest;
  (function(DefinitionRequest2) {
    DefinitionRequest2.method = "textDocument/definition";
    DefinitionRequest2.type = new messages_1.ProtocolRequestType(DefinitionRequest2.method);
    DefinitionRequest2.resultType = new vscode_jsonrpc_1.ProgressType();
  })(DefinitionRequest = exports2.DefinitionRequest || (exports2.DefinitionRequest = {}));
  var ReferencesRequest;
  (function(ReferencesRequest2) {
    ReferencesRequest2.method = "textDocument/references";
    ReferencesRequest2.type = new messages_1.ProtocolRequestType(ReferencesRequest2.method);
    ReferencesRequest2.resultType = new vscode_jsonrpc_1.ProgressType();
  })(ReferencesRequest = exports2.ReferencesRequest || (exports2.ReferencesRequest = {}));
  var DocumentHighlightRequest;
  (function(DocumentHighlightRequest2) {
    DocumentHighlightRequest2.method = "textDocument/documentHighlight";
    DocumentHighlightRequest2.type = new messages_1.ProtocolRequestType(DocumentHighlightRequest2.method);
    DocumentHighlightRequest2.resultType = new vscode_jsonrpc_1.ProgressType();
  })(DocumentHighlightRequest = exports2.DocumentHighlightRequest || (exports2.DocumentHighlightRequest = {}));
  var DocumentSymbolRequest;
  (function(DocumentSymbolRequest2) {
    DocumentSymbolRequest2.method = "textDocument/documentSymbol";
    DocumentSymbolRequest2.type = new messages_1.ProtocolRequestType(DocumentSymbolRequest2.method);
    DocumentSymbolRequest2.resultType = new vscode_jsonrpc_1.ProgressType();
  })(DocumentSymbolRequest = exports2.DocumentSymbolRequest || (exports2.DocumentSymbolRequest = {}));
  var CodeActionRequest2;
  (function(CodeActionRequest3) {
    CodeActionRequest3.method = "textDocument/codeAction";
    CodeActionRequest3.type = new messages_1.ProtocolRequestType(CodeActionRequest3.method);
    CodeActionRequest3.resultType = new vscode_jsonrpc_1.ProgressType();
  })(CodeActionRequest2 = exports2.CodeActionRequest || (exports2.CodeActionRequest = {}));
  var WorkspaceSymbolRequest;
  (function(WorkspaceSymbolRequest2) {
    WorkspaceSymbolRequest2.method = "workspace/symbol";
    WorkspaceSymbolRequest2.type = new messages_1.ProtocolRequestType(WorkspaceSymbolRequest2.method);
    WorkspaceSymbolRequest2.resultType = new vscode_jsonrpc_1.ProgressType();
  })(WorkspaceSymbolRequest = exports2.WorkspaceSymbolRequest || (exports2.WorkspaceSymbolRequest = {}));
  var CodeLensRequest;
  (function(CodeLensRequest2) {
    CodeLensRequest2.type = new messages_1.ProtocolRequestType("textDocument/codeLens");
    CodeLensRequest2.resultType = new vscode_jsonrpc_1.ProgressType();
  })(CodeLensRequest = exports2.CodeLensRequest || (exports2.CodeLensRequest = {}));
  var CodeLensResolveRequest;
  (function(CodeLensResolveRequest2) {
    CodeLensResolveRequest2.type = new messages_1.ProtocolRequestType("codeLens/resolve");
  })(CodeLensResolveRequest = exports2.CodeLensResolveRequest || (exports2.CodeLensResolveRequest = {}));
  var DocumentLinkRequest;
  (function(DocumentLinkRequest2) {
    DocumentLinkRequest2.method = "textDocument/documentLink";
    DocumentLinkRequest2.type = new messages_1.ProtocolRequestType(DocumentLinkRequest2.method);
    DocumentLinkRequest2.resultType = new vscode_jsonrpc_1.ProgressType();
  })(DocumentLinkRequest = exports2.DocumentLinkRequest || (exports2.DocumentLinkRequest = {}));
  var DocumentLinkResolveRequest;
  (function(DocumentLinkResolveRequest2) {
    DocumentLinkResolveRequest2.type = new messages_1.ProtocolRequestType("documentLink/resolve");
  })(DocumentLinkResolveRequest = exports2.DocumentLinkResolveRequest || (exports2.DocumentLinkResolveRequest = {}));
  var DocumentFormattingRequest;
  (function(DocumentFormattingRequest2) {
    DocumentFormattingRequest2.method = "textDocument/formatting";
    DocumentFormattingRequest2.type = new messages_1.ProtocolRequestType(DocumentFormattingRequest2.method);
  })(DocumentFormattingRequest = exports2.DocumentFormattingRequest || (exports2.DocumentFormattingRequest = {}));
  var DocumentRangeFormattingRequest;
  (function(DocumentRangeFormattingRequest2) {
    DocumentRangeFormattingRequest2.method = "textDocument/rangeFormatting";
    DocumentRangeFormattingRequest2.type = new messages_1.ProtocolRequestType(DocumentRangeFormattingRequest2.method);
  })(DocumentRangeFormattingRequest = exports2.DocumentRangeFormattingRequest || (exports2.DocumentRangeFormattingRequest = {}));
  var DocumentOnTypeFormattingRequest;
  (function(DocumentOnTypeFormattingRequest2) {
    DocumentOnTypeFormattingRequest2.method = "textDocument/onTypeFormatting";
    DocumentOnTypeFormattingRequest2.type = new messages_1.ProtocolRequestType(DocumentOnTypeFormattingRequest2.method);
  })(DocumentOnTypeFormattingRequest = exports2.DocumentOnTypeFormattingRequest || (exports2.DocumentOnTypeFormattingRequest = {}));
  var RenameRequest;
  (function(RenameRequest2) {
    RenameRequest2.method = "textDocument/rename";
    RenameRequest2.type = new messages_1.ProtocolRequestType(RenameRequest2.method);
  })(RenameRequest = exports2.RenameRequest || (exports2.RenameRequest = {}));
  var PrepareRenameRequest;
  (function(PrepareRenameRequest2) {
    PrepareRenameRequest2.method = "textDocument/prepareRename";
    PrepareRenameRequest2.type = new messages_1.ProtocolRequestType(PrepareRenameRequest2.method);
  })(PrepareRenameRequest = exports2.PrepareRenameRequest || (exports2.PrepareRenameRequest = {}));
  var ExecuteCommandRequest;
  (function(ExecuteCommandRequest2) {
    ExecuteCommandRequest2.type = new messages_1.ProtocolRequestType("workspace/executeCommand");
  })(ExecuteCommandRequest = exports2.ExecuteCommandRequest || (exports2.ExecuteCommandRequest = {}));
  var ApplyWorkspaceEditRequest;
  (function(ApplyWorkspaceEditRequest2) {
    ApplyWorkspaceEditRequest2.type = new messages_1.ProtocolRequestType("workspace/applyEdit");
  })(ApplyWorkspaceEditRequest = exports2.ApplyWorkspaceEditRequest || (exports2.ApplyWorkspaceEditRequest = {}));
});

// node_modules/vscode-languageserver-protocol/lib/protocol.callHierarchy.proposed.js
var require_protocol_callHierarchy_proposed = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var messages_1 = require_messages2();
  var CallHierarchyPrepareRequest;
  (function(CallHierarchyPrepareRequest2) {
    CallHierarchyPrepareRequest2.method = "textDocument/prepareCallHierarchy";
    CallHierarchyPrepareRequest2.type = new messages_1.ProtocolRequestType(CallHierarchyPrepareRequest2.method);
  })(CallHierarchyPrepareRequest = exports2.CallHierarchyPrepareRequest || (exports2.CallHierarchyPrepareRequest = {}));
  var CallHierarchyIncomingCallsRequest;
  (function(CallHierarchyIncomingCallsRequest2) {
    CallHierarchyIncomingCallsRequest2.method = "callHierarchy/incomingCalls";
    CallHierarchyIncomingCallsRequest2.type = new messages_1.ProtocolRequestType(CallHierarchyIncomingCallsRequest2.method);
  })(CallHierarchyIncomingCallsRequest = exports2.CallHierarchyIncomingCallsRequest || (exports2.CallHierarchyIncomingCallsRequest = {}));
  var CallHierarchyOutgoingCallsRequest;
  (function(CallHierarchyOutgoingCallsRequest2) {
    CallHierarchyOutgoingCallsRequest2.method = "callHierarchy/outgoingCalls";
    CallHierarchyOutgoingCallsRequest2.type = new messages_1.ProtocolRequestType(CallHierarchyOutgoingCallsRequest2.method);
  })(CallHierarchyOutgoingCallsRequest = exports2.CallHierarchyOutgoingCallsRequest || (exports2.CallHierarchyOutgoingCallsRequest = {}));
});

// node_modules/vscode-languageserver-protocol/lib/protocol.sematicTokens.proposed.js
var require_protocol_sematicTokens_proposed = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var messages_1 = require_messages2();
  var SemanticTokenTypes;
  (function(SemanticTokenTypes2) {
    SemanticTokenTypes2["comment"] = "comment";
    SemanticTokenTypes2["keyword"] = "keyword";
    SemanticTokenTypes2["string"] = "string";
    SemanticTokenTypes2["number"] = "number";
    SemanticTokenTypes2["regexp"] = "regexp";
    SemanticTokenTypes2["operator"] = "operator";
    SemanticTokenTypes2["namespace"] = "namespace";
    SemanticTokenTypes2["type"] = "type";
    SemanticTokenTypes2["struct"] = "struct";
    SemanticTokenTypes2["class"] = "class";
    SemanticTokenTypes2["interface"] = "interface";
    SemanticTokenTypes2["enum"] = "enum";
    SemanticTokenTypes2["typeParameter"] = "typeParameter";
    SemanticTokenTypes2["function"] = "function";
    SemanticTokenTypes2["member"] = "member";
    SemanticTokenTypes2["property"] = "property";
    SemanticTokenTypes2["macro"] = "macro";
    SemanticTokenTypes2["variable"] = "variable";
    SemanticTokenTypes2["parameter"] = "parameter";
    SemanticTokenTypes2["label"] = "label";
  })(SemanticTokenTypes = exports2.SemanticTokenTypes || (exports2.SemanticTokenTypes = {}));
  var SemanticTokenModifiers;
  (function(SemanticTokenModifiers2) {
    SemanticTokenModifiers2["documentation"] = "documentation";
    SemanticTokenModifiers2["declaration"] = "declaration";
    SemanticTokenModifiers2["definition"] = "definition";
    SemanticTokenModifiers2["reference"] = "reference";
    SemanticTokenModifiers2["static"] = "static";
    SemanticTokenModifiers2["abstract"] = "abstract";
    SemanticTokenModifiers2["deprecated"] = "deprecated";
    SemanticTokenModifiers2["async"] = "async";
    SemanticTokenModifiers2["volatile"] = "volatile";
    SemanticTokenModifiers2["readonly"] = "readonly";
  })(SemanticTokenModifiers = exports2.SemanticTokenModifiers || (exports2.SemanticTokenModifiers = {}));
  var SemanticTokens;
  (function(SemanticTokens2) {
    function is(value) {
      const candidate = value;
      return candidate !== void 0 && (candidate.resultId === void 0 || typeof candidate.resultId === "string") && Array.isArray(candidate.data) && (candidate.data.length === 0 || typeof candidate.data[0] === "number");
    }
    SemanticTokens2.is = is;
  })(SemanticTokens = exports2.SemanticTokens || (exports2.SemanticTokens = {}));
  var SemanticTokensRequest;
  (function(SemanticTokensRequest2) {
    SemanticTokensRequest2.method = "textDocument/semanticTokens";
    SemanticTokensRequest2.type = new messages_1.ProtocolRequestType(SemanticTokensRequest2.method);
  })(SemanticTokensRequest = exports2.SemanticTokensRequest || (exports2.SemanticTokensRequest = {}));
  var SemanticTokensEditsRequest;
  (function(SemanticTokensEditsRequest2) {
    SemanticTokensEditsRequest2.method = "textDocument/semanticTokens/edits";
    SemanticTokensEditsRequest2.type = new messages_1.ProtocolRequestType(SemanticTokensEditsRequest2.method);
  })(SemanticTokensEditsRequest = exports2.SemanticTokensEditsRequest || (exports2.SemanticTokensEditsRequest = {}));
  var SemanticTokensRangeRequest;
  (function(SemanticTokensRangeRequest2) {
    SemanticTokensRangeRequest2.method = "textDocument/semanticTokens/range";
    SemanticTokensRangeRequest2.type = new messages_1.ProtocolRequestType(SemanticTokensRangeRequest2.method);
  })(SemanticTokensRangeRequest = exports2.SemanticTokensRangeRequest || (exports2.SemanticTokensRangeRequest = {}));
});

// node_modules/vscode-languageserver-protocol/lib/main.js
var require_main3 = __commonJS((exports2) => {
  "use strict";
  function __export2(m) {
    for (var p in m)
      if (!exports2.hasOwnProperty(p))
        exports2[p] = m[p];
  }
  Object.defineProperty(exports2, "__esModule", {value: true});
  var vscode_jsonrpc_1 = require_main();
  exports2.ErrorCodes = vscode_jsonrpc_1.ErrorCodes;
  exports2.ResponseError = vscode_jsonrpc_1.ResponseError;
  exports2.CancellationToken = vscode_jsonrpc_1.CancellationToken;
  exports2.CancellationTokenSource = vscode_jsonrpc_1.CancellationTokenSource;
  exports2.Disposable = vscode_jsonrpc_1.Disposable;
  exports2.Event = vscode_jsonrpc_1.Event;
  exports2.Emitter = vscode_jsonrpc_1.Emitter;
  exports2.Trace = vscode_jsonrpc_1.Trace;
  exports2.TraceFormat = vscode_jsonrpc_1.TraceFormat;
  exports2.SetTraceNotification = vscode_jsonrpc_1.SetTraceNotification;
  exports2.LogTraceNotification = vscode_jsonrpc_1.LogTraceNotification;
  exports2.RequestType = vscode_jsonrpc_1.RequestType;
  exports2.RequestType0 = vscode_jsonrpc_1.RequestType0;
  exports2.NotificationType = vscode_jsonrpc_1.NotificationType;
  exports2.NotificationType0 = vscode_jsonrpc_1.NotificationType0;
  exports2.MessageReader = vscode_jsonrpc_1.MessageReader;
  exports2.MessageWriter = vscode_jsonrpc_1.MessageWriter;
  exports2.ConnectionStrategy = vscode_jsonrpc_1.ConnectionStrategy;
  exports2.StreamMessageReader = vscode_jsonrpc_1.StreamMessageReader;
  exports2.StreamMessageWriter = vscode_jsonrpc_1.StreamMessageWriter;
  exports2.IPCMessageReader = vscode_jsonrpc_1.IPCMessageReader;
  exports2.IPCMessageWriter = vscode_jsonrpc_1.IPCMessageWriter;
  exports2.createClientPipeTransport = vscode_jsonrpc_1.createClientPipeTransport;
  exports2.createServerPipeTransport = vscode_jsonrpc_1.createServerPipeTransport;
  exports2.generateRandomPipeName = vscode_jsonrpc_1.generateRandomPipeName;
  exports2.createClientSocketTransport = vscode_jsonrpc_1.createClientSocketTransport;
  exports2.createServerSocketTransport = vscode_jsonrpc_1.createServerSocketTransport;
  exports2.ProgressType = vscode_jsonrpc_1.ProgressType;
  __export2(require_main2());
  __export2(require_protocol());
  var callHierarchy = require_protocol_callHierarchy_proposed();
  var st = require_protocol_sematicTokens_proposed();
  var Proposed;
  (function(Proposed2) {
    let CallHierarchyPrepareRequest;
    (function(CallHierarchyPrepareRequest2) {
      CallHierarchyPrepareRequest2.method = callHierarchy.CallHierarchyPrepareRequest.method;
      CallHierarchyPrepareRequest2.type = callHierarchy.CallHierarchyPrepareRequest.type;
    })(CallHierarchyPrepareRequest = Proposed2.CallHierarchyPrepareRequest || (Proposed2.CallHierarchyPrepareRequest = {}));
    let CallHierarchyIncomingCallsRequest;
    (function(CallHierarchyIncomingCallsRequest2) {
      CallHierarchyIncomingCallsRequest2.method = callHierarchy.CallHierarchyIncomingCallsRequest.method;
      CallHierarchyIncomingCallsRequest2.type = callHierarchy.CallHierarchyIncomingCallsRequest.type;
    })(CallHierarchyIncomingCallsRequest = Proposed2.CallHierarchyIncomingCallsRequest || (Proposed2.CallHierarchyIncomingCallsRequest = {}));
    let CallHierarchyOutgoingCallsRequest;
    (function(CallHierarchyOutgoingCallsRequest2) {
      CallHierarchyOutgoingCallsRequest2.method = callHierarchy.CallHierarchyOutgoingCallsRequest.method;
      CallHierarchyOutgoingCallsRequest2.type = callHierarchy.CallHierarchyOutgoingCallsRequest.type;
    })(CallHierarchyOutgoingCallsRequest = Proposed2.CallHierarchyOutgoingCallsRequest || (Proposed2.CallHierarchyOutgoingCallsRequest = {}));
    Proposed2.SemanticTokenTypes = st.SemanticTokenTypes;
    Proposed2.SemanticTokenModifiers = st.SemanticTokenModifiers;
    Proposed2.SemanticTokens = st.SemanticTokens;
    let SemanticTokensRequest;
    (function(SemanticTokensRequest2) {
      SemanticTokensRequest2.method = st.SemanticTokensRequest.method;
      SemanticTokensRequest2.type = st.SemanticTokensRequest.type;
    })(SemanticTokensRequest = Proposed2.SemanticTokensRequest || (Proposed2.SemanticTokensRequest = {}));
    let SemanticTokensEditsRequest;
    (function(SemanticTokensEditsRequest2) {
      SemanticTokensEditsRequest2.method = st.SemanticTokensEditsRequest.method;
      SemanticTokensEditsRequest2.type = st.SemanticTokensEditsRequest.type;
    })(SemanticTokensEditsRequest = Proposed2.SemanticTokensEditsRequest || (Proposed2.SemanticTokensEditsRequest = {}));
    let SemanticTokensRangeRequest;
    (function(SemanticTokensRangeRequest2) {
      SemanticTokensRangeRequest2.method = st.SemanticTokensRangeRequest.method;
      SemanticTokensRangeRequest2.type = st.SemanticTokensRangeRequest.type;
    })(SemanticTokensRangeRequest = Proposed2.SemanticTokensRangeRequest || (Proposed2.SemanticTokensRangeRequest = {}));
  })(Proposed = exports2.Proposed || (exports2.Proposed = {}));
  function createProtocolConnection(reader, writer, logger, strategy) {
    return vscode_jsonrpc_1.createMessageConnection(reader, writer, logger, strategy);
  }
  exports2.createProtocolConnection = createProtocolConnection;
});

// node_modules/pify/index.js
var require_pify = __commonJS((exports2, module2) => {
  "use strict";
  var processFn = function(fn, P, opts) {
    return function() {
      var that = this;
      var args = new Array(arguments.length);
      for (var i = 0; i < arguments.length; i++) {
        args[i] = arguments[i];
      }
      return new P(function(resolve, reject) {
        args.push(function(err, result) {
          if (err) {
            reject(err);
          } else if (opts.multiArgs) {
            var results = new Array(arguments.length - 1);
            for (var i2 = 1; i2 < arguments.length; i2++) {
              results[i2 - 1] = arguments[i2];
            }
            resolve(results);
          } else {
            resolve(result);
          }
        });
        fn.apply(that, args);
      });
    };
  };
  var pify = module2.exports = function(obj, P, opts) {
    if (typeof P !== "function") {
      opts = P;
      P = Promise;
    }
    opts = opts || {};
    opts.exclude = opts.exclude || [/.+Sync$/];
    var filter = function(key) {
      var match = function(pattern) {
        return typeof pattern === "string" ? key === pattern : pattern.test(key);
      };
      return opts.include ? opts.include.some(match) : !opts.exclude.some(match);
    };
    var ret = typeof obj === "function" ? function() {
      if (opts.excludeMain) {
        return obj.apply(this, arguments);
      }
      return processFn(obj, P, opts).apply(this, arguments);
    } : {};
    return Object.keys(obj).reduce(function(ret2, key) {
      var x = obj[key];
      ret2[key] = typeof x === "function" && filter(key) ? processFn(x, P, opts) : x;
      return ret2;
    }, ret);
  };
  pify.all = pify;
});

// node_modules/executable/index.js
var require_executable = __commonJS((exports2, module2) => {
  "use strict";
  var fs2 = require("fs");
  var pify = require_pify();
  var isExe = (mode, gid, uid) => {
    if (process.platform === "win32") {
      return true;
    }
    const isGroup = gid ? process.getgid && gid === process.getgid() : true;
    const isUser = uid ? process.getuid && uid === process.getuid() : true;
    return Boolean(mode & 1 || mode & 8 && isGroup || mode & 64 && isUser);
  };
  module2.exports = (name) => {
    if (typeof name !== "string") {
      return Promise.reject(new TypeError("Expected a string"));
    }
    return pify(fs2.stat)(name).then((stats) => stats && stats.isFile() && isExe(stats.mode, stats.gid, stats.uid));
  };
  module2.exports.sync = (name) => {
    if (typeof name !== "string") {
      throw new TypeError("Expected a string");
    }
    const stats = fs2.statSync(name);
    return stats && stats.isFile() && isExe(stats.mode, stats.gid, stats.uid);
  };
  module2.exports.checkMode = isExe;
});

// node_modules/isexe/windows.js
var require_windows = __commonJS((exports2, module2) => {
  module2.exports = isexe;
  isexe.sync = sync;
  var fs2 = require("fs");
  function checkPathExt(path2, options) {
    var pathext = options.pathExt !== void 0 ? options.pathExt : process.env.PATHEXT;
    if (!pathext) {
      return true;
    }
    pathext = pathext.split(";");
    if (pathext.indexOf("") !== -1) {
      return true;
    }
    for (var i = 0; i < pathext.length; i++) {
      var p = pathext[i].toLowerCase();
      if (p && path2.substr(-p.length).toLowerCase() === p) {
        return true;
      }
    }
    return false;
  }
  function checkStat(stat, path2, options) {
    if (!stat.isSymbolicLink() && !stat.isFile()) {
      return false;
    }
    return checkPathExt(path2, options);
  }
  function isexe(path2, options, cb) {
    fs2.stat(path2, function(er, stat) {
      cb(er, er ? false : checkStat(stat, path2, options));
    });
  }
  function sync(path2, options) {
    return checkStat(fs2.statSync(path2), path2, options);
  }
});

// node_modules/isexe/mode.js
var require_mode = __commonJS((exports2, module2) => {
  module2.exports = isexe;
  isexe.sync = sync;
  var fs2 = require("fs");
  function isexe(path2, options, cb) {
    fs2.stat(path2, function(er, stat) {
      cb(er, er ? false : checkStat(stat, options));
    });
  }
  function sync(path2, options) {
    return checkStat(fs2.statSync(path2), options);
  }
  function checkStat(stat, options) {
    return stat.isFile() && checkMode(stat, options);
  }
  function checkMode(stat, options) {
    var mod = stat.mode;
    var uid = stat.uid;
    var gid = stat.gid;
    var myUid = options.uid !== void 0 ? options.uid : process.getuid && process.getuid();
    var myGid = options.gid !== void 0 ? options.gid : process.getgid && process.getgid();
    var u = parseInt("100", 8);
    var g = parseInt("010", 8);
    var o = parseInt("001", 8);
    var ug = u | g;
    var ret = mod & o || mod & g && gid === myGid || mod & u && uid === myUid || mod & ug && myUid === 0;
    return ret;
  }
});

// node_modules/isexe/index.js
var require_isexe = __commonJS((exports2, module2) => {
  var fs2 = require("fs");
  var core;
  if (process.platform === "win32" || global.TESTING_WINDOWS) {
    core = require_windows();
  } else {
    core = require_mode();
  }
  module2.exports = isexe;
  isexe.sync = sync;
  function isexe(path2, options, cb) {
    if (typeof options === "function") {
      cb = options;
      options = {};
    }
    if (!cb) {
      if (typeof Promise !== "function") {
        throw new TypeError("callback not provided");
      }
      return new Promise(function(resolve, reject) {
        isexe(path2, options || {}, function(er, is) {
          if (er) {
            reject(er);
          } else {
            resolve(is);
          }
        });
      });
    }
    core(path2, options || {}, function(er, is) {
      if (er) {
        if (er.code === "EACCES" || options && options.ignoreErrors) {
          er = null;
          is = false;
        }
      }
      cb(er, is);
    });
  }
  function sync(path2, options) {
    try {
      return core.sync(path2, options || {});
    } catch (er) {
      if (options && options.ignoreErrors || er.code === "EACCES") {
        return false;
      } else {
        throw er;
      }
    }
  }
});

// node_modules/which/which.js
var require_which = __commonJS((exports2, module2) => {
  var isWindows = process.platform === "win32" || process.env.OSTYPE === "cygwin" || process.env.OSTYPE === "msys";
  var path2 = require("path");
  var COLON = isWindows ? ";" : ":";
  var isexe = require_isexe();
  var getNotFoundError = (cmd) => Object.assign(new Error(`not found: ${cmd}`), {code: "ENOENT"});
  var getPathInfo = (cmd, opt) => {
    const colon = opt.colon || COLON;
    const pathEnv = cmd.match(/\//) || isWindows && cmd.match(/\\/) ? [""] : [
      ...isWindows ? [process.cwd()] : [],
      ...(opt.path || process.env.PATH || "").split(colon)
    ];
    const pathExtExe = isWindows ? opt.pathExt || process.env.PATHEXT || ".EXE;.CMD;.BAT;.COM" : "";
    const pathExt = isWindows ? pathExtExe.split(colon) : [""];
    if (isWindows) {
      if (cmd.indexOf(".") !== -1 && pathExt[0] !== "")
        pathExt.unshift("");
    }
    return {
      pathEnv,
      pathExt,
      pathExtExe
    };
  };
  var which2 = (cmd, opt, cb) => {
    if (typeof opt === "function") {
      cb = opt;
      opt = {};
    }
    if (!opt)
      opt = {};
    const {pathEnv, pathExt, pathExtExe} = getPathInfo(cmd, opt);
    const found = [];
    const step = (i) => new Promise((resolve, reject) => {
      if (i === pathEnv.length)
        return opt.all && found.length ? resolve(found) : reject(getNotFoundError(cmd));
      const ppRaw = pathEnv[i];
      const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
      const pCmd = path2.join(pathPart, cmd);
      const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
      resolve(subStep(p, i, 0));
    });
    const subStep = (p, i, ii) => new Promise((resolve, reject) => {
      if (ii === pathExt.length)
        return resolve(step(i + 1));
      const ext = pathExt[ii];
      isexe(p + ext, {pathExt: pathExtExe}, (er, is) => {
        if (!er && is) {
          if (opt.all)
            found.push(p + ext);
          else
            return resolve(p + ext);
        }
        return resolve(subStep(p, i, ii + 1));
      });
    });
    return cb ? step(0).then((res) => cb(null, res), cb) : step(0);
  };
  var whichSync = (cmd, opt) => {
    opt = opt || {};
    const {pathEnv, pathExt, pathExtExe} = getPathInfo(cmd, opt);
    const found = [];
    for (let i = 0; i < pathEnv.length; i++) {
      const ppRaw = pathEnv[i];
      const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
      const pCmd = path2.join(pathPart, cmd);
      const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
      for (let j = 0; j < pathExt.length; j++) {
        const cur = p + pathExt[j];
        try {
          const is = isexe.sync(cur, {pathExt: pathExtExe});
          if (is) {
            if (opt.all)
              found.push(cur);
            else
              return cur;
          }
        } catch (ex) {
        }
      }
    }
    if (opt.all && found.length)
      return found;
    if (opt.nothrow)
      return null;
    throw getNotFoundError(cmd);
  };
  module2.exports = which2;
  which2.sync = whichSync;
});

// node_modules/ms/index.js
var require_ms = __commonJS((exports2, module2) => {
  var s = 1e3;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var w = d * 7;
  var y = d * 365.25;
  module2.exports = function(val, options) {
    options = options || {};
    var type = typeof val;
    if (type === "string" && val.length > 0) {
      return parse(val);
    } else if (type === "number" && isFinite(val)) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
  };
  function parse(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || "ms").toLowerCase();
    switch (type) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y;
      case "weeks":
      case "week":
      case "w":
        return n * w;
      case "days":
      case "day":
      case "d":
        return n * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return void 0;
    }
  }
  function fmtShort(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return Math.round(ms / d) + "d";
    }
    if (msAbs >= h) {
      return Math.round(ms / h) + "h";
    }
    if (msAbs >= m) {
      return Math.round(ms / m) + "m";
    }
    if (msAbs >= s) {
      return Math.round(ms / s) + "s";
    }
    return ms + "ms";
  }
  function fmtLong(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return plural(ms, msAbs, d, "day");
    }
    if (msAbs >= h) {
      return plural(ms, msAbs, h, "hour");
    }
    if (msAbs >= m) {
      return plural(ms, msAbs, m, "minute");
    }
    if (msAbs >= s) {
      return plural(ms, msAbs, s, "second");
    }
    return ms + " ms";
  }
  function plural(ms, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
  }
});

// node_modules/debug/src/common.js
var require_common = __commonJS((exports2, module2) => {
  function setup(env) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = require_ms();
    Object.keys(env).forEach((key) => {
      createDebug[key] = env[key];
    });
    createDebug.instances = [];
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace) {
      let hash = 0;
      for (let i = 0; i < namespace.length; i++) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function createDebug(namespace) {
      let prevTime;
      function debug(...args) {
        if (!debug.enabled) {
          return;
        }
        const self = debug;
        const curr = Number(new Date());
        const ms = curr - (prevTime || curr);
        self.diff = ms;
        self.prev = prevTime;
        self.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        let index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
          if (match === "%%") {
            return match;
          }
          index++;
          const formatter = createDebug.formatters[format];
          if (typeof formatter === "function") {
            const val = args[index];
            match = formatter.call(self, val);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        createDebug.formatArgs.call(self, args);
        const logFn = self.log || createDebug.log;
        logFn.apply(self, args);
      }
      debug.namespace = namespace;
      debug.enabled = createDebug.enabled(namespace);
      debug.useColors = createDebug.useColors();
      debug.color = createDebug.selectColor(namespace);
      debug.destroy = destroy;
      debug.extend = extend;
      if (typeof createDebug.init === "function") {
        createDebug.init(debug);
      }
      createDebug.instances.push(debug);
      return debug;
    }
    function destroy() {
      const index = createDebug.instances.indexOf(this);
      if (index !== -1) {
        createDebug.instances.splice(index, 1);
        return true;
      }
      return false;
    }
    function extend(namespace, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.names = [];
      createDebug.skips = [];
      let i;
      const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      const len = split.length;
      for (i = 0; i < len; i++) {
        if (!split[i]) {
          continue;
        }
        namespaces = split[i].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          createDebug.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
        } else {
          createDebug.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
      for (i = 0; i < createDebug.instances.length; i++) {
        const instance = createDebug.instances[i];
        instance.enabled = createDebug.enabled(instance.namespace);
      }
    }
    function disable() {
      const namespaces = [
        ...createDebug.names.map(toNamespace),
        ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }
    function enabled(name) {
      if (name[name.length - 1] === "*") {
        return true;
      }
      let i;
      let len;
      for (i = 0, len = createDebug.skips.length; i < len; i++) {
        if (createDebug.skips[i].test(name)) {
          return false;
        }
      }
      for (i = 0, len = createDebug.names.length; i < len; i++) {
        if (createDebug.names[i].test(name)) {
          return true;
        }
      }
      return false;
    }
    function toNamespace(regexp) {
      return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
    }
    function coerce(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  }
  module2.exports = setup;
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS((exports2, module2) => {
  exports2.formatArgs = formatArgs;
  exports2.save = save;
  exports2.load = load;
  exports2.useColors = useColors;
  exports2.storage = localstorage();
  exports2.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function useColors() {
    if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
      return true;
    }
    if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
      return false;
    }
    return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function formatArgs(args) {
    args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
    if (!this.useColors) {
      return;
    }
    const c = "color: " + this.color;
    args.splice(1, 0, c, "color: inherit");
    let index = 0;
    let lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, (match) => {
      if (match === "%%") {
        return;
      }
      index++;
      if (match === "%c") {
        lastC = index;
      }
    });
    args.splice(lastC, 0, c);
  }
  exports2.log = console.debug || console.log || (() => {
  });
  function save(namespaces) {
    try {
      if (namespaces) {
        exports2.storage.setItem("debug", namespaces);
      } else {
        exports2.storage.removeItem("debug");
      }
    } catch (error) {
    }
  }
  function load() {
    let r;
    try {
      r = exports2.storage.getItem("debug");
    } catch (error) {
    }
    if (!r && typeof process !== "undefined" && "env" in process) {
      r = process.env.DEBUG;
    }
    return r;
  }
  function localstorage() {
    try {
      return localStorage;
    } catch (error) {
    }
  }
  module2.exports = require_common()(exports2);
  var {formatters} = module2.exports;
  formatters.j = function(v) {
    try {
      return JSON.stringify(v);
    } catch (error) {
      return "[UnexpectedJSONParseError]: " + error.message;
    }
  };
});

// node_modules/has-flag/index.js
var require_has_flag = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = (flag, argv = process.argv) => {
    const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
    const position = argv.indexOf(prefix + flag);
    const terminatorPosition = argv.indexOf("--");
    return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
  };
});

// node_modules/supports-color/index.js
var require_supports_color = __commonJS((exports2, module2) => {
  "use strict";
  var os = require("os");
  var tty = require("tty");
  var hasFlag = require_has_flag();
  var {env} = process;
  var forceColor;
  if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
    forceColor = 0;
  } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
    forceColor = 1;
  }
  if ("FORCE_COLOR" in env) {
    if (env.FORCE_COLOR === "true") {
      forceColor = 1;
    } else if (env.FORCE_COLOR === "false") {
      forceColor = 0;
    } else {
      forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
    }
  }
  function translateLevel(level) {
    if (level === 0) {
      return false;
    }
    return {
      level,
      hasBasic: true,
      has256: level >= 2,
      has16m: level >= 3
    };
  }
  function supportsColor(haveStream, streamIsTTY) {
    if (forceColor === 0) {
      return 0;
    }
    if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
      return 3;
    }
    if (hasFlag("color=256")) {
      return 2;
    }
    if (haveStream && !streamIsTTY && forceColor === void 0) {
      return 0;
    }
    const min = forceColor || 0;
    if (env.TERM === "dumb") {
      return min;
    }
    if (process.platform === "win32") {
      const osRelease = os.release().split(".");
      if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
        return Number(osRelease[2]) >= 14931 ? 3 : 2;
      }
      return 1;
    }
    if ("CI" in env) {
      if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some((sign) => sign in env) || env.CI_NAME === "codeship") {
        return 1;
      }
      return min;
    }
    if ("TEAMCITY_VERSION" in env) {
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
    }
    if ("GITHUB_ACTIONS" in env) {
      return 1;
    }
    if (env.COLORTERM === "truecolor") {
      return 3;
    }
    if ("TERM_PROGRAM" in env) {
      const version = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (env.TERM_PROGRAM) {
        case "iTerm.app":
          return version >= 3 ? 3 : 2;
        case "Apple_Terminal":
          return 2;
      }
    }
    if (/-256(color)?$/i.test(env.TERM)) {
      return 2;
    }
    if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
      return 1;
    }
    if ("COLORTERM" in env) {
      return 1;
    }
    return min;
  }
  function getSupportLevel(stream2) {
    const level = supportsColor(stream2, stream2 && stream2.isTTY);
    return translateLevel(level);
  }
  module2.exports = {
    supportsColor: getSupportLevel,
    stdout: translateLevel(supportsColor(true, tty.isatty(1))),
    stderr: translateLevel(supportsColor(true, tty.isatty(2)))
  };
});

// node_modules/debug/src/node.js
var require_node = __commonJS((exports2, module2) => {
  var tty = require("tty");
  var util2 = require("util");
  exports2.init = init;
  exports2.log = log;
  exports2.formatArgs = formatArgs;
  exports2.save = save;
  exports2.load = load;
  exports2.useColors = useColors;
  exports2.colors = [6, 2, 3, 4, 5, 1];
  try {
    const supportsColor = require_supports_color();
    if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
      exports2.colors = [
        20,
        21,
        26,
        27,
        32,
        33,
        38,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        56,
        57,
        62,
        63,
        68,
        69,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        92,
        93,
        98,
        99,
        112,
        113,
        128,
        129,
        134,
        135,
        148,
        149,
        160,
        161,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        171,
        172,
        173,
        178,
        179,
        184,
        185,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        203,
        204,
        205,
        206,
        207,
        208,
        209,
        214,
        215,
        220,
        221
      ];
    }
  } catch (error) {
  }
  exports2.inspectOpts = Object.keys(process.env).filter((key) => {
    return /^debug_/i.test(key);
  }).reduce((obj, key) => {
    const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
      return k.toUpperCase();
    });
    let val = process.env[key];
    if (/^(yes|on|true|enabled)$/i.test(val)) {
      val = true;
    } else if (/^(no|off|false|disabled)$/i.test(val)) {
      val = false;
    } else if (val === "null") {
      val = null;
    } else {
      val = Number(val);
    }
    obj[prop] = val;
    return obj;
  }, {});
  function useColors() {
    return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(process.stderr.fd);
  }
  function formatArgs(args) {
    const {namespace: name, useColors: useColors2} = this;
    if (useColors2) {
      const c = this.color;
      const colorCode = "[3" + (c < 8 ? c : "8;5;" + c);
      const prefix = `  ${colorCode};1m${name} [0m`;
      args[0] = prefix + args[0].split("\n").join("\n" + prefix);
      args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "[0m");
    } else {
      args[0] = getDate() + name + " " + args[0];
    }
  }
  function getDate() {
    if (exports2.inspectOpts.hideDate) {
      return "";
    }
    return new Date().toISOString() + " ";
  }
  function log(...args) {
    return process.stderr.write(util2.format(...args) + "\n");
  }
  function save(namespaces) {
    if (namespaces) {
      process.env.DEBUG = namespaces;
    } else {
      delete process.env.DEBUG;
    }
  }
  function load() {
    return process.env.DEBUG;
  }
  function init(debug) {
    debug.inspectOpts = {};
    const keys = Object.keys(exports2.inspectOpts);
    for (let i = 0; i < keys.length; i++) {
      debug.inspectOpts[keys[i]] = exports2.inspectOpts[keys[i]];
    }
  }
  module2.exports = require_common()(exports2);
  var {formatters} = module2.exports;
  formatters.o = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util2.inspect(v, this.inspectOpts).replace(/\s*\n\s*/g, " ");
  };
  formatters.O = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util2.inspect(v, this.inspectOpts);
  };
});

// node_modules/debug/src/index.js
var require_src = __commonJS((exports2, module2) => {
  if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
    module2.exports = require_browser();
  } else {
    module2.exports = require_node();
  }
});

// node_modules/agent-base/dist/src/promisify.js
var require_promisify = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  function promisify(fn) {
    return function(req, opts) {
      return new Promise((resolve, reject) => {
        fn.call(this, req, opts, (err, rtn) => {
          if (err) {
            reject(err);
          } else {
            resolve(rtn);
          }
        });
      });
    };
  }
  exports2.default = promisify;
});

// node_modules/agent-base/dist/src/index.js
var require_src2 = __commonJS((exports2, module2) => {
  "use strict";
  var __importDefault = exports2 && exports2.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {default: mod};
  };
  var events_1 = require("events");
  var debug_1 = __importDefault(require_src());
  var promisify_1 = __importDefault(require_promisify());
  var debug = debug_1.default("agent-base");
  function isAgent(v) {
    return Boolean(v) && typeof v.addRequest === "function";
  }
  function isSecureEndpoint() {
    const {stack} = new Error();
    if (typeof stack !== "string")
      return false;
    return stack.split("\n").some((l) => l.indexOf("(https.js:") !== -1);
  }
  function createAgent(callback, opts) {
    return new createAgent.Agent(callback, opts);
  }
  (function(createAgent2) {
    class Agent extends events_1.EventEmitter {
      constructor(callback, _opts) {
        super();
        let opts = _opts;
        if (typeof callback === "function") {
          this.callback = callback;
        } else if (callback) {
          opts = callback;
        }
        this.timeout = null;
        if (opts && typeof opts.timeout === "number") {
          this.timeout = opts.timeout;
        }
        this.maxFreeSockets = 1;
        this.maxSockets = 1;
        this.sockets = {};
        this.requests = {};
      }
      get defaultPort() {
        if (typeof this.explicitDefaultPort === "number") {
          return this.explicitDefaultPort;
        }
        return isSecureEndpoint() ? 443 : 80;
      }
      set defaultPort(v) {
        this.explicitDefaultPort = v;
      }
      get protocol() {
        if (typeof this.explicitProtocol === "string") {
          return this.explicitProtocol;
        }
        return isSecureEndpoint() ? "https:" : "http:";
      }
      set protocol(v) {
        this.explicitProtocol = v;
      }
      callback(req, opts, fn) {
        throw new Error('"agent-base" has no default implementation, you must subclass and override `callback()`');
      }
      addRequest(req, _opts) {
        const opts = Object.assign({}, _opts);
        if (typeof opts.secureEndpoint !== "boolean") {
          opts.secureEndpoint = isSecureEndpoint();
        }
        if (opts.host == null) {
          opts.host = "localhost";
        }
        if (opts.port == null) {
          opts.port = opts.secureEndpoint ? 443 : 80;
        }
        if (opts.protocol == null) {
          opts.protocol = opts.secureEndpoint ? "https:" : "http:";
        }
        if (opts.host && opts.path) {
          delete opts.path;
        }
        delete opts.agent;
        delete opts.hostname;
        delete opts._defaultAgent;
        delete opts.defaultPort;
        delete opts.createConnection;
        req._last = true;
        req.shouldKeepAlive = false;
        let timedOut = false;
        let timeoutId = null;
        const timeoutMs = opts.timeout || this.timeout;
        const onerror = (err) => {
          if (req._hadError)
            return;
          req.emit("error", err);
          req._hadError = true;
        };
        const ontimeout = () => {
          timeoutId = null;
          timedOut = true;
          const err = new Error(`A "socket" was not created for HTTP request before ${timeoutMs}ms`);
          err.code = "ETIMEOUT";
          onerror(err);
        };
        const callbackError = (err) => {
          if (timedOut)
            return;
          if (timeoutId !== null) {
            clearTimeout(timeoutId);
            timeoutId = null;
          }
          onerror(err);
        };
        const onsocket = (socket) => {
          if (timedOut)
            return;
          if (timeoutId != null) {
            clearTimeout(timeoutId);
            timeoutId = null;
          }
          if (isAgent(socket)) {
            debug("Callback returned another Agent instance %o", socket.constructor.name);
            socket.addRequest(req, opts);
            return;
          }
          if (socket) {
            socket.once("free", () => {
              this.freeSocket(socket, opts);
            });
            req.onSocket(socket);
            return;
          }
          const err = new Error(`no Duplex stream was returned to agent-base for \`${req.method} ${req.path}\``);
          onerror(err);
        };
        if (typeof this.callback !== "function") {
          onerror(new Error("`callback` is not defined"));
          return;
        }
        if (!this.promisifiedCallback) {
          if (this.callback.length >= 3) {
            debug("Converting legacy callback function to promise");
            this.promisifiedCallback = promisify_1.default(this.callback);
          } else {
            this.promisifiedCallback = this.callback;
          }
        }
        if (typeof timeoutMs === "number" && timeoutMs > 0) {
          timeoutId = setTimeout(ontimeout, timeoutMs);
        }
        if ("port" in opts && typeof opts.port !== "number") {
          opts.port = Number(opts.port);
        }
        try {
          debug("Resolving socket for %o request: %o", opts.protocol, `${req.method} ${req.path}`);
          Promise.resolve(this.promisifiedCallback(req, opts)).then(onsocket, callbackError);
        } catch (err) {
          Promise.reject(err).catch(callbackError);
        }
      }
      freeSocket(socket, opts) {
        debug("Freeing socket %o %o", socket.constructor.name, opts);
        socket.destroy();
      }
      destroy() {
        debug("Destroying agent %o", this.constructor.name);
      }
    }
    createAgent2.Agent = Agent;
    createAgent2.prototype = createAgent2.Agent.prototype;
  })(createAgent || (createAgent = {}));
  module2.exports = createAgent;
});

// node_modules/https-proxy-agent/dist/parse-proxy-response.js
var require_parse_proxy_response = __commonJS((exports2) => {
  "use strict";
  var __importDefault = exports2 && exports2.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {default: mod};
  };
  Object.defineProperty(exports2, "__esModule", {value: true});
  var debug_1 = __importDefault(require_src());
  var debug = debug_1.default("https-proxy-agent:parse-proxy-response");
  function parseProxyResponse(socket) {
    return new Promise((resolve, reject) => {
      let buffersLength = 0;
      const buffers = [];
      function read() {
        const b = socket.read();
        if (b)
          ondata(b);
        else
          socket.once("readable", read);
      }
      function cleanup() {
        socket.removeListener("end", onend);
        socket.removeListener("error", onerror);
        socket.removeListener("close", onclose);
        socket.removeListener("readable", read);
      }
      function onclose(err) {
        debug("onclose had error %o", err);
      }
      function onend() {
        debug("onend");
      }
      function onerror(err) {
        cleanup();
        debug("onerror %o", err);
        reject(err);
      }
      function ondata(b) {
        buffers.push(b);
        buffersLength += b.length;
        const buffered = Buffer.concat(buffers, buffersLength);
        const endOfHeaders = buffered.indexOf("\r\n\r\n");
        if (endOfHeaders === -1) {
          debug("have not received end of HTTP headers yet...");
          read();
          return;
        }
        const firstLine = buffered.toString("ascii", 0, buffered.indexOf("\r\n"));
        const statusCode = +firstLine.split(" ")[1];
        debug("got proxy server response: %o", firstLine);
        resolve({
          statusCode,
          buffered
        });
      }
      socket.on("error", onerror);
      socket.on("close", onclose);
      socket.on("end", onend);
      read();
    });
  }
  exports2.default = parseProxyResponse;
});

// node_modules/https-proxy-agent/dist/agent.js
var require_agent = __commonJS((exports2) => {
  "use strict";
  var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __importDefault = exports2 && exports2.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {default: mod};
  };
  Object.defineProperty(exports2, "__esModule", {value: true});
  var net_1 = __importDefault(require("net"));
  var tls_1 = __importDefault(require("tls"));
  var url_1 = __importDefault(require("url"));
  var assert_1 = __importDefault(require("assert"));
  var debug_1 = __importDefault(require_src());
  var agent_base_1 = require_src2();
  var parse_proxy_response_1 = __importDefault(require_parse_proxy_response());
  var debug = debug_1.default("https-proxy-agent:agent");
  var HttpsProxyAgent2 = class extends agent_base_1.Agent {
    constructor(_opts) {
      let opts;
      if (typeof _opts === "string") {
        opts = url_1.default.parse(_opts);
      } else {
        opts = _opts;
      }
      if (!opts) {
        throw new Error("an HTTP(S) proxy server `host` and `port` must be specified!");
      }
      debug("creating new HttpsProxyAgent instance: %o", opts);
      super(opts);
      const proxy = Object.assign({}, opts);
      this.secureProxy = opts.secureProxy || isHTTPS(proxy.protocol);
      proxy.host = proxy.hostname || proxy.host;
      if (typeof proxy.port === "string") {
        proxy.port = parseInt(proxy.port, 10);
      }
      if (!proxy.port && proxy.host) {
        proxy.port = this.secureProxy ? 443 : 80;
      }
      if (this.secureProxy && !("ALPNProtocols" in proxy)) {
        proxy.ALPNProtocols = ["http 1.1"];
      }
      if (proxy.host && proxy.path) {
        delete proxy.path;
        delete proxy.pathname;
      }
      this.proxy = proxy;
    }
    callback(req, opts) {
      return __awaiter(this, void 0, void 0, function* () {
        const {proxy, secureProxy} = this;
        let socket;
        if (secureProxy) {
          debug("Creating `tls.Socket`: %o", proxy);
          socket = tls_1.default.connect(proxy);
        } else {
          debug("Creating `net.Socket`: %o", proxy);
          socket = net_1.default.connect(proxy);
        }
        const headers = Object.assign({}, proxy.headers);
        const hostname = `${opts.host}:${opts.port}`;
        let payload = `CONNECT ${hostname} HTTP/1.1\r
`;
        if (proxy.auth) {
          headers["Proxy-Authorization"] = `Basic ${Buffer.from(proxy.auth).toString("base64")}`;
        }
        let {host, port, secureEndpoint} = opts;
        if (!isDefaultPort(port, secureEndpoint)) {
          host += `:${port}`;
        }
        headers.Host = host;
        headers.Connection = "close";
        for (const name of Object.keys(headers)) {
          payload += `${name}: ${headers[name]}\r
`;
        }
        const proxyResponsePromise = parse_proxy_response_1.default(socket);
        socket.write(`${payload}\r
`);
        const {statusCode, buffered} = yield proxyResponsePromise;
        if (statusCode === 200) {
          req.once("socket", resume);
          if (opts.secureEndpoint) {
            const servername = opts.servername || opts.host;
            if (!servername) {
              throw new Error('Could not determine "servername"');
            }
            debug("Upgrading socket connection to TLS");
            return tls_1.default.connect(Object.assign(Object.assign({}, omit(opts, "host", "hostname", "path", "port")), {
              socket,
              servername
            }));
          }
          return socket;
        }
        socket.destroy();
        const fakeSocket = new net_1.default.Socket();
        fakeSocket.readable = true;
        req.once("socket", (s) => {
          debug("replaying proxy buffer for failed request");
          assert_1.default(s.listenerCount("data") > 0);
          s.push(buffered);
          s.push(null);
        });
        return fakeSocket;
      });
    }
  };
  exports2.default = HttpsProxyAgent2;
  function resume(socket) {
    socket.resume();
  }
  function isDefaultPort(port, secure) {
    return Boolean(!secure && port === 80 || secure && port === 443);
  }
  function isHTTPS(protocol) {
    return typeof protocol === "string" ? /^https:?$/i.test(protocol) : false;
  }
  function omit(obj, ...keys) {
    const ret = {};
    let key;
    for (key in obj) {
      if (!keys.includes(key)) {
        ret[key] = obj[key];
      }
    }
    return ret;
  }
});

// node_modules/https-proxy-agent/dist/index.js
var require_dist = __commonJS((exports2, module2) => {
  "use strict";
  var __importDefault = exports2 && exports2.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {default: mod};
  };
  var agent_1 = __importDefault(require_agent());
  function createHttpsProxyAgent(opts) {
    return new agent_1.default(opts);
  }
  (function(createHttpsProxyAgent2) {
    createHttpsProxyAgent2.HttpsProxyAgent = agent_1.default;
    createHttpsProxyAgent2.prototype = agent_1.default.prototype;
  })(createHttpsProxyAgent || (createHttpsProxyAgent = {}));
  module2.exports = createHttpsProxyAgent;
});

// src/index.ts
__markAsModule(exports);
__export(exports, {
  activate: () => activate
});
var import_coc7 = __toModule(require("coc.nvim"));
var import_fs3 = __toModule(require("fs"));

// src/commands.ts
var import_child_process2 = __toModule(require("child_process"));
var import_coc6 = __toModule(require("coc.nvim"));
var import_readline = __toModule(require("readline"));
var import_vscode_languageserver_protocol4 = __toModule(require_main3());

// src/ctx.ts
var import_coc5 = __toModule(require("coc.nvim"));
var import_executable = __toModule(require_executable());
var import_fs2 = __toModule(require("fs"));
var import_os = __toModule(require("os"));
var import_path2 = __toModule(require("path"));
var import_vscode_languageserver_protocol3 = __toModule(require_main3());
var import_which = __toModule(require_which());

// src/client.ts
var import_coc = __toModule(require("coc.nvim"));
var import_vscode_languageserver_protocol = __toModule(require_main3());
var ExperimentalFeatures = class {
  fillClientCapabilities(capabilities) {
    var _a;
    const completionCaps = capabilities.textDocument.completion;
    completionCaps.completionItem.resolveSupport = {
      properties: ["documentation", "detail", "additionalTextEdits"]
    };
    const codeActionCaps = capabilities.textDocument.codeAction;
    codeActionCaps.resolveSupport = {
      properties: ["edit"]
    };
    const caps = (_a = capabilities.experimental) != null ? _a : {};
    caps.snippetTextEdit = true;
    caps.resolveCodeAction = true;
    caps.statusNotification = true;
    capabilities.experimental = caps;
  }
  initialize() {
  }
  dispose() {
  }
};
function isCodeActionWithoutEditsAndCommands(value) {
  const candidate = value;
  return candidate && (candidate.diagnostics === void 0 || Array.isArray(candidate.diagnostics)) && (candidate.kind === void 0 || typeof candidate.kind === "string") && candidate.edit === void 0 && candidate.command === void 0;
}
function createClient(bin, extra) {
  var _a;
  let folder = ".";
  if ((_a = import_coc.workspace.workspaceFolder) == null ? void 0 : _a.uri.length) {
    folder = import_coc.Uri.parse(import_coc.workspace.workspaceFolder.uri).fsPath;
  }
  const env = Object.assign(Object.assign({}, process.env), extra);
  const run2 = {
    command: bin,
    options: {env, cwd: folder}
  };
  const serverOptions = run2;
  const outputChannel = import_coc.window.createOutputChannel("Rust Analyzer Language Server Trace");
  const clientOptions = {
    documentSelector: [{language: "rust"}, {pattern: "Cargo.toml"}],
    initializationOptions: import_coc.workspace.getConfiguration("rust-analyzer"),
    middleware: {
      async resolveCompletionItem(item, token, next) {
        if (item.data && !item.data.position) {
          delete item.data;
        }
        return await next(item, token);
      },
      async provideCodeActions(document2, range, context, token) {
        const params = {
          textDocument: {uri: document2.uri},
          range,
          context
        };
        const values = await client.sendRequest(import_vscode_languageserver_protocol.CodeActionRequest.type, params, token);
        if (values === null)
          return void 0;
        const result = [];
        for (const item of values) {
          if (import_vscode_languageserver_protocol.CodeAction.is(item)) {
            result.push(item);
            continue;
          }
          if (!isCodeActionWithoutEditsAndCommands(item)) {
            console.error("isCodeActionWithoutEditsAndCommands:", JSON.stringify(item));
            continue;
          }
          const command = {
            command: "rust-analyzer.resolveCodeAction",
            title: item.title,
            arguments: [item]
          };
          const kind = item.kind;
          result.push(import_vscode_languageserver_protocol.CodeAction.create(item.title, command, kind));
        }
        return result;
      }
    },
    outputChannel
  };
  const client = new import_coc.LanguageClient("rust-analyzer", "Rust Analyzer Language Server", serverOptions, clientOptions);
  client._tracer = {
    log: (messageOrDataObject, data) => {
      if (typeof messageOrDataObject === "string") {
        if (messageOrDataObject.includes("rust-analyzer/publishDecorations") || messageOrDataObject.includes("rust-analyzer/decorationsRequest")) {
        } else {
          client.logTrace(messageOrDataObject, data);
        }
      } else {
        client.logObjectTrace(messageOrDataObject);
      }
    }
  };
  client.registerFeature(new ExperimentalFeatures());
  return client;
}

// src/config.ts
var import_coc2 = __toModule(require("coc.nvim"));
var Config = class {
  constructor() {
    this.rootSection = "rust-analyzer";
    this.requiresReloadOpts = ["server", "cargo", "procMacro", "files", "updates", "lens", "hoverActions", "inlayHints"].map((opt) => `${this.rootSection}.${opt}`);
    import_coc2.workspace.onDidChangeConfiguration((event) => this.onConfigChange(event));
    this.cfg = import_coc2.workspace.getConfiguration(this.rootSection);
  }
  async onConfigChange(event) {
    this.cfg = import_coc2.workspace.getConfiguration(this.rootSection);
    const requiresReloadOpt = this.requiresReloadOpts.find((opt) => event.affectsConfiguration(opt));
    if (!requiresReloadOpt)
      return;
    const msg = `Changing "${requiresReloadOpt}" requires a reload`;
    const prompt = await import_coc2.window.showPrompt(`${msg}. Reload now?`);
    if (prompt) {
      await import_coc2.commands.executeCommand(`workbench.action.reloadWindow`);
    }
  }
  get serverPath() {
    var _a;
    return (_a = this.cfg.get("server.path")) != null ? _a : this.cfg.get("serverPath");
  }
  get serverExtraEnv() {
    var _a;
    return (_a = this.cfg.get("server.extraEnv")) != null ? _a : {};
  }
  get inlayHints() {
    const hasVirtualText = import_coc2.workspace.isNvim && import_coc2.workspace.nvim.hasFunction("nvim_buf_set_virtual_text");
    return {
      enable: hasVirtualText && this.cfg.get("inlayHints.enable"),
      typeHints: hasVirtualText && this.cfg.get("inlayHints.typeHints"),
      typeHintsSeparator: this.cfg.get("inlayHints.typeHintsSeparator"),
      typeHintsWithVariable: this.cfg.get("inlayHints.typeHintsWithVariable"),
      chainingHints: hasVirtualText && this.cfg.get("inlayHints.chainingHints"),
      chainingHintsSeparator: this.cfg.get("inlayHints.chainingHintsSeparator"),
      refreshOnInsertMode: hasVirtualText && this.cfg.get("inlayHints.refreshOnInsertMode")
    };
  }
  get debug() {
    return {
      runtime: this.cfg.get("debug.runtime"),
      vimspectorConfiguration: {
        name: this.cfg.get("debug.vimspector.configuration.name")
      }
    };
  }
  get prompt() {
    return this.cfg.get("updates.prompt");
  }
  get channel() {
    return this.cfg.get("updates.channel");
  }
  get cargo() {
    return {
      autoreload: this.cfg.get("cargo.autoreload")
    };
  }
  get terminal() {
    return {
      startinsert: this.cfg.get("terminal.startinsert")
    };
  }
  get enable() {
    return this.cfg.get("enable");
  }
};

// src/downloader.ts
var import_child_process = __toModule(require("child_process"));
var import_coc3 = __toModule(require("coc.nvim"));
var import_crypto = __toModule(require("crypto"));
var import_fs = __toModule(require("fs"));
var import_https_proxy_agent = __toModule(require_dist());

// node_modules/node-fetch/lib/index.mjs
var import_stream = __toModule(require("stream"));
var import_http = __toModule(require("http"));
var import_url = __toModule(require("url"));
var import_https = __toModule(require("https"));
var import_zlib = __toModule(require("zlib"));
var Readable = import_stream.default.Readable;
var BUFFER = Symbol("buffer");
var TYPE = Symbol("type");
var Blob = class {
  constructor() {
    this[TYPE] = "";
    const blobParts = arguments[0];
    const options = arguments[1];
    const buffers = [];
    let size = 0;
    if (blobParts) {
      const a = blobParts;
      const length = Number(a.length);
      for (let i = 0; i < length; i++) {
        const element = a[i];
        let buffer;
        if (element instanceof Buffer) {
          buffer = element;
        } else if (ArrayBuffer.isView(element)) {
          buffer = Buffer.from(element.buffer, element.byteOffset, element.byteLength);
        } else if (element instanceof ArrayBuffer) {
          buffer = Buffer.from(element);
        } else if (element instanceof Blob) {
          buffer = element[BUFFER];
        } else {
          buffer = Buffer.from(typeof element === "string" ? element : String(element));
        }
        size += buffer.length;
        buffers.push(buffer);
      }
    }
    this[BUFFER] = Buffer.concat(buffers);
    let type = options && options.type !== void 0 && String(options.type).toLowerCase();
    if (type && !/[^\u0020-\u007E]/.test(type)) {
      this[TYPE] = type;
    }
  }
  get size() {
    return this[BUFFER].length;
  }
  get type() {
    return this[TYPE];
  }
  text() {
    return Promise.resolve(this[BUFFER].toString());
  }
  arrayBuffer() {
    const buf = this[BUFFER];
    const ab = buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
    return Promise.resolve(ab);
  }
  stream() {
    const readable = new Readable();
    readable._read = function() {
    };
    readable.push(this[BUFFER]);
    readable.push(null);
    return readable;
  }
  toString() {
    return "[object Blob]";
  }
  slice() {
    const size = this.size;
    const start = arguments[0];
    const end = arguments[1];
    let relativeStart, relativeEnd;
    if (start === void 0) {
      relativeStart = 0;
    } else if (start < 0) {
      relativeStart = Math.max(size + start, 0);
    } else {
      relativeStart = Math.min(start, size);
    }
    if (end === void 0) {
      relativeEnd = size;
    } else if (end < 0) {
      relativeEnd = Math.max(size + end, 0);
    } else {
      relativeEnd = Math.min(end, size);
    }
    const span = Math.max(relativeEnd - relativeStart, 0);
    const buffer = this[BUFFER];
    const slicedBuffer = buffer.slice(relativeStart, relativeStart + span);
    const blob = new Blob([], {type: arguments[2]});
    blob[BUFFER] = slicedBuffer;
    return blob;
  }
};
Object.defineProperties(Blob.prototype, {
  size: {enumerable: true},
  type: {enumerable: true},
  slice: {enumerable: true}
});
Object.defineProperty(Blob.prototype, Symbol.toStringTag, {
  value: "Blob",
  writable: false,
  enumerable: false,
  configurable: true
});
function FetchError(message, type, systemError) {
  Error.call(this, message);
  this.message = message;
  this.type = type;
  if (systemError) {
    this.code = this.errno = systemError.code;
  }
  Error.captureStackTrace(this, this.constructor);
}
FetchError.prototype = Object.create(Error.prototype);
FetchError.prototype.constructor = FetchError;
FetchError.prototype.name = "FetchError";
var convert;
try {
  convert = require("encoding").convert;
} catch (e) {
}
var INTERNALS = Symbol("Body internals");
var PassThrough = import_stream.default.PassThrough;
function Body(body) {
  var _this = this;
  var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$size = _ref.size;
  let size = _ref$size === void 0 ? 0 : _ref$size;
  var _ref$timeout = _ref.timeout;
  let timeout = _ref$timeout === void 0 ? 0 : _ref$timeout;
  if (body == null) {
    body = null;
  } else if (isURLSearchParams(body)) {
    body = Buffer.from(body.toString());
  } else if (isBlob(body))
    ;
  else if (Buffer.isBuffer(body))
    ;
  else if (Object.prototype.toString.call(body) === "[object ArrayBuffer]") {
    body = Buffer.from(body);
  } else if (ArrayBuffer.isView(body)) {
    body = Buffer.from(body.buffer, body.byteOffset, body.byteLength);
  } else if (body instanceof import_stream.default)
    ;
  else {
    body = Buffer.from(String(body));
  }
  this[INTERNALS] = {
    body,
    disturbed: false,
    error: null
  };
  this.size = size;
  this.timeout = timeout;
  if (body instanceof import_stream.default) {
    body.on("error", function(err) {
      const error = err.name === "AbortError" ? err : new FetchError(`Invalid response body while trying to fetch ${_this.url}: ${err.message}`, "system", err);
      _this[INTERNALS].error = error;
    });
  }
}
Body.prototype = {
  get body() {
    return this[INTERNALS].body;
  },
  get bodyUsed() {
    return this[INTERNALS].disturbed;
  },
  arrayBuffer() {
    return consumeBody.call(this).then(function(buf) {
      return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
    });
  },
  blob() {
    let ct = this.headers && this.headers.get("content-type") || "";
    return consumeBody.call(this).then(function(buf) {
      return Object.assign(new Blob([], {
        type: ct.toLowerCase()
      }), {
        [BUFFER]: buf
      });
    });
  },
  json() {
    var _this2 = this;
    return consumeBody.call(this).then(function(buffer) {
      try {
        return JSON.parse(buffer.toString());
      } catch (err) {
        return Body.Promise.reject(new FetchError(`invalid json response body at ${_this2.url} reason: ${err.message}`, "invalid-json"));
      }
    });
  },
  text() {
    return consumeBody.call(this).then(function(buffer) {
      return buffer.toString();
    });
  },
  buffer() {
    return consumeBody.call(this);
  },
  textConverted() {
    var _this3 = this;
    return consumeBody.call(this).then(function(buffer) {
      return convertBody(buffer, _this3.headers);
    });
  }
};
Object.defineProperties(Body.prototype, {
  body: {enumerable: true},
  bodyUsed: {enumerable: true},
  arrayBuffer: {enumerable: true},
  blob: {enumerable: true},
  json: {enumerable: true},
  text: {enumerable: true}
});
Body.mixIn = function(proto) {
  for (const name of Object.getOwnPropertyNames(Body.prototype)) {
    if (!(name in proto)) {
      const desc = Object.getOwnPropertyDescriptor(Body.prototype, name);
      Object.defineProperty(proto, name, desc);
    }
  }
};
function consumeBody() {
  var _this4 = this;
  if (this[INTERNALS].disturbed) {
    return Body.Promise.reject(new TypeError(`body used already for: ${this.url}`));
  }
  this[INTERNALS].disturbed = true;
  if (this[INTERNALS].error) {
    return Body.Promise.reject(this[INTERNALS].error);
  }
  let body = this.body;
  if (body === null) {
    return Body.Promise.resolve(Buffer.alloc(0));
  }
  if (isBlob(body)) {
    body = body.stream();
  }
  if (Buffer.isBuffer(body)) {
    return Body.Promise.resolve(body);
  }
  if (!(body instanceof import_stream.default)) {
    return Body.Promise.resolve(Buffer.alloc(0));
  }
  let accum = [];
  let accumBytes = 0;
  let abort = false;
  return new Body.Promise(function(resolve, reject) {
    let resTimeout;
    if (_this4.timeout) {
      resTimeout = setTimeout(function() {
        abort = true;
        reject(new FetchError(`Response timeout while trying to fetch ${_this4.url} (over ${_this4.timeout}ms)`, "body-timeout"));
      }, _this4.timeout);
    }
    body.on("error", function(err) {
      if (err.name === "AbortError") {
        abort = true;
        reject(err);
      } else {
        reject(new FetchError(`Invalid response body while trying to fetch ${_this4.url}: ${err.message}`, "system", err));
      }
    });
    body.on("data", function(chunk) {
      if (abort || chunk === null) {
        return;
      }
      if (_this4.size && accumBytes + chunk.length > _this4.size) {
        abort = true;
        reject(new FetchError(`content size at ${_this4.url} over limit: ${_this4.size}`, "max-size"));
        return;
      }
      accumBytes += chunk.length;
      accum.push(chunk);
    });
    body.on("end", function() {
      if (abort) {
        return;
      }
      clearTimeout(resTimeout);
      try {
        resolve(Buffer.concat(accum, accumBytes));
      } catch (err) {
        reject(new FetchError(`Could not create Buffer from response body for ${_this4.url}: ${err.message}`, "system", err));
      }
    });
  });
}
function convertBody(buffer, headers) {
  if (typeof convert !== "function") {
    throw new Error("The package `encoding` must be installed to use the textConverted() function");
  }
  const ct = headers.get("content-type");
  let charset = "utf-8";
  let res, str;
  if (ct) {
    res = /charset=([^;]*)/i.exec(ct);
  }
  str = buffer.slice(0, 1024).toString();
  if (!res && str) {
    res = /<meta.+?charset=(['"])(.+?)\1/i.exec(str);
  }
  if (!res && str) {
    res = /<meta[\s]+?http-equiv=(['"])content-type\1[\s]+?content=(['"])(.+?)\2/i.exec(str);
    if (!res) {
      res = /<meta[\s]+?content=(['"])(.+?)\1[\s]+?http-equiv=(['"])content-type\3/i.exec(str);
      if (res) {
        res.pop();
      }
    }
    if (res) {
      res = /charset=(.*)/i.exec(res.pop());
    }
  }
  if (!res && str) {
    res = /<\?xml.+?encoding=(['"])(.+?)\1/i.exec(str);
  }
  if (res) {
    charset = res.pop();
    if (charset === "gb2312" || charset === "gbk") {
      charset = "gb18030";
    }
  }
  return convert(buffer, "UTF-8", charset).toString();
}
function isURLSearchParams(obj) {
  if (typeof obj !== "object" || typeof obj.append !== "function" || typeof obj.delete !== "function" || typeof obj.get !== "function" || typeof obj.getAll !== "function" || typeof obj.has !== "function" || typeof obj.set !== "function") {
    return false;
  }
  return obj.constructor.name === "URLSearchParams" || Object.prototype.toString.call(obj) === "[object URLSearchParams]" || typeof obj.sort === "function";
}
function isBlob(obj) {
  return typeof obj === "object" && typeof obj.arrayBuffer === "function" && typeof obj.type === "string" && typeof obj.stream === "function" && typeof obj.constructor === "function" && typeof obj.constructor.name === "string" && /^(Blob|File)$/.test(obj.constructor.name) && /^(Blob|File)$/.test(obj[Symbol.toStringTag]);
}
function clone(instance) {
  let p1, p2;
  let body = instance.body;
  if (instance.bodyUsed) {
    throw new Error("cannot clone body after it is used");
  }
  if (body instanceof import_stream.default && typeof body.getBoundary !== "function") {
    p1 = new PassThrough();
    p2 = new PassThrough();
    body.pipe(p1);
    body.pipe(p2);
    instance[INTERNALS].body = p1;
    body = p2;
  }
  return body;
}
function extractContentType(body) {
  if (body === null) {
    return null;
  } else if (typeof body === "string") {
    return "text/plain;charset=UTF-8";
  } else if (isURLSearchParams(body)) {
    return "application/x-www-form-urlencoded;charset=UTF-8";
  } else if (isBlob(body)) {
    return body.type || null;
  } else if (Buffer.isBuffer(body)) {
    return null;
  } else if (Object.prototype.toString.call(body) === "[object ArrayBuffer]") {
    return null;
  } else if (ArrayBuffer.isView(body)) {
    return null;
  } else if (typeof body.getBoundary === "function") {
    return `multipart/form-data;boundary=${body.getBoundary()}`;
  } else if (body instanceof import_stream.default) {
    return null;
  } else {
    return "text/plain;charset=UTF-8";
  }
}
function getTotalBytes(instance) {
  const body = instance.body;
  if (body === null) {
    return 0;
  } else if (isBlob(body)) {
    return body.size;
  } else if (Buffer.isBuffer(body)) {
    return body.length;
  } else if (body && typeof body.getLengthSync === "function") {
    if (body._lengthRetrievers && body._lengthRetrievers.length == 0 || body.hasKnownLength && body.hasKnownLength()) {
      return body.getLengthSync();
    }
    return null;
  } else {
    return null;
  }
}
function writeToStream(dest, instance) {
  const body = instance.body;
  if (body === null) {
    dest.end();
  } else if (isBlob(body)) {
    body.stream().pipe(dest);
  } else if (Buffer.isBuffer(body)) {
    dest.write(body);
    dest.end();
  } else {
    body.pipe(dest);
  }
}
Body.Promise = global.Promise;
var invalidTokenRegex = /[^\^_`a-zA-Z\-0-9!#$%&'*+.|~]/;
var invalidHeaderCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
function validateName(name) {
  name = `${name}`;
  if (invalidTokenRegex.test(name) || name === "") {
    throw new TypeError(`${name} is not a legal HTTP header name`);
  }
}
function validateValue(value) {
  value = `${value}`;
  if (invalidHeaderCharRegex.test(value)) {
    throw new TypeError(`${value} is not a legal HTTP header value`);
  }
}
function find(map, name) {
  name = name.toLowerCase();
  for (const key in map) {
    if (key.toLowerCase() === name) {
      return key;
    }
  }
  return void 0;
}
var MAP = Symbol("map");
var Headers = class {
  constructor() {
    let init = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : void 0;
    this[MAP] = Object.create(null);
    if (init instanceof Headers) {
      const rawHeaders = init.raw();
      const headerNames = Object.keys(rawHeaders);
      for (const headerName of headerNames) {
        for (const value of rawHeaders[headerName]) {
          this.append(headerName, value);
        }
      }
      return;
    }
    if (init == null)
      ;
    else if (typeof init === "object") {
      const method = init[Symbol.iterator];
      if (method != null) {
        if (typeof method !== "function") {
          throw new TypeError("Header pairs must be iterable");
        }
        const pairs = [];
        for (const pair of init) {
          if (typeof pair !== "object" || typeof pair[Symbol.iterator] !== "function") {
            throw new TypeError("Each header pair must be iterable");
          }
          pairs.push(Array.from(pair));
        }
        for (const pair of pairs) {
          if (pair.length !== 2) {
            throw new TypeError("Each header pair must be a name/value tuple");
          }
          this.append(pair[0], pair[1]);
        }
      } else {
        for (const key of Object.keys(init)) {
          const value = init[key];
          this.append(key, value);
        }
      }
    } else {
      throw new TypeError("Provided initializer must be an object");
    }
  }
  get(name) {
    name = `${name}`;
    validateName(name);
    const key = find(this[MAP], name);
    if (key === void 0) {
      return null;
    }
    return this[MAP][key].join(", ");
  }
  forEach(callback) {
    let thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : void 0;
    let pairs = getHeaders(this);
    let i = 0;
    while (i < pairs.length) {
      var _pairs$i = pairs[i];
      const name = _pairs$i[0], value = _pairs$i[1];
      callback.call(thisArg, value, name, this);
      pairs = getHeaders(this);
      i++;
    }
  }
  set(name, value) {
    name = `${name}`;
    value = `${value}`;
    validateName(name);
    validateValue(value);
    const key = find(this[MAP], name);
    this[MAP][key !== void 0 ? key : name] = [value];
  }
  append(name, value) {
    name = `${name}`;
    value = `${value}`;
    validateName(name);
    validateValue(value);
    const key = find(this[MAP], name);
    if (key !== void 0) {
      this[MAP][key].push(value);
    } else {
      this[MAP][name] = [value];
    }
  }
  has(name) {
    name = `${name}`;
    validateName(name);
    return find(this[MAP], name) !== void 0;
  }
  delete(name) {
    name = `${name}`;
    validateName(name);
    const key = find(this[MAP], name);
    if (key !== void 0) {
      delete this[MAP][key];
    }
  }
  raw() {
    return this[MAP];
  }
  keys() {
    return createHeadersIterator(this, "key");
  }
  values() {
    return createHeadersIterator(this, "value");
  }
  [Symbol.iterator]() {
    return createHeadersIterator(this, "key+value");
  }
};
Headers.prototype.entries = Headers.prototype[Symbol.iterator];
Object.defineProperty(Headers.prototype, Symbol.toStringTag, {
  value: "Headers",
  writable: false,
  enumerable: false,
  configurable: true
});
Object.defineProperties(Headers.prototype, {
  get: {enumerable: true},
  forEach: {enumerable: true},
  set: {enumerable: true},
  append: {enumerable: true},
  has: {enumerable: true},
  delete: {enumerable: true},
  keys: {enumerable: true},
  values: {enumerable: true},
  entries: {enumerable: true}
});
function getHeaders(headers) {
  let kind = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "key+value";
  const keys = Object.keys(headers[MAP]).sort();
  return keys.map(kind === "key" ? function(k) {
    return k.toLowerCase();
  } : kind === "value" ? function(k) {
    return headers[MAP][k].join(", ");
  } : function(k) {
    return [k.toLowerCase(), headers[MAP][k].join(", ")];
  });
}
var INTERNAL = Symbol("internal");
function createHeadersIterator(target, kind) {
  const iterator = Object.create(HeadersIteratorPrototype);
  iterator[INTERNAL] = {
    target,
    kind,
    index: 0
  };
  return iterator;
}
var HeadersIteratorPrototype = Object.setPrototypeOf({
  next() {
    if (!this || Object.getPrototypeOf(this) !== HeadersIteratorPrototype) {
      throw new TypeError("Value of `this` is not a HeadersIterator");
    }
    var _INTERNAL = this[INTERNAL];
    const target = _INTERNAL.target, kind = _INTERNAL.kind, index = _INTERNAL.index;
    const values = getHeaders(target, kind);
    const len = values.length;
    if (index >= len) {
      return {
        value: void 0,
        done: true
      };
    }
    this[INTERNAL].index = index + 1;
    return {
      value: values[index],
      done: false
    };
  }
}, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));
Object.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {
  value: "HeadersIterator",
  writable: false,
  enumerable: false,
  configurable: true
});
function exportNodeCompatibleHeaders(headers) {
  const obj = Object.assign({__proto__: null}, headers[MAP]);
  const hostHeaderKey = find(headers[MAP], "Host");
  if (hostHeaderKey !== void 0) {
    obj[hostHeaderKey] = obj[hostHeaderKey][0];
  }
  return obj;
}
function createHeadersLenient(obj) {
  const headers = new Headers();
  for (const name of Object.keys(obj)) {
    if (invalidTokenRegex.test(name)) {
      continue;
    }
    if (Array.isArray(obj[name])) {
      for (const val of obj[name]) {
        if (invalidHeaderCharRegex.test(val)) {
          continue;
        }
        if (headers[MAP][name] === void 0) {
          headers[MAP][name] = [val];
        } else {
          headers[MAP][name].push(val);
        }
      }
    } else if (!invalidHeaderCharRegex.test(obj[name])) {
      headers[MAP][name] = [obj[name]];
    }
  }
  return headers;
}
var INTERNALS$1 = Symbol("Response internals");
var STATUS_CODES = import_http.default.STATUS_CODES;
var Response = class {
  constructor() {
    let body = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
    let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    Body.call(this, body, opts);
    const status2 = opts.status || 200;
    const headers = new Headers(opts.headers);
    if (body != null && !headers.has("Content-Type")) {
      const contentType = extractContentType(body);
      if (contentType) {
        headers.append("Content-Type", contentType);
      }
    }
    this[INTERNALS$1] = {
      url: opts.url,
      status: status2,
      statusText: opts.statusText || STATUS_CODES[status2],
      headers,
      counter: opts.counter
    };
  }
  get url() {
    return this[INTERNALS$1].url || "";
  }
  get status() {
    return this[INTERNALS$1].status;
  }
  get ok() {
    return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;
  }
  get redirected() {
    return this[INTERNALS$1].counter > 0;
  }
  get statusText() {
    return this[INTERNALS$1].statusText;
  }
  get headers() {
    return this[INTERNALS$1].headers;
  }
  clone() {
    return new Response(clone(this), {
      url: this.url,
      status: this.status,
      statusText: this.statusText,
      headers: this.headers,
      ok: this.ok,
      redirected: this.redirected
    });
  }
};
Body.mixIn(Response.prototype);
Object.defineProperties(Response.prototype, {
  url: {enumerable: true},
  status: {enumerable: true},
  ok: {enumerable: true},
  redirected: {enumerable: true},
  statusText: {enumerable: true},
  headers: {enumerable: true},
  clone: {enumerable: true}
});
Object.defineProperty(Response.prototype, Symbol.toStringTag, {
  value: "Response",
  writable: false,
  enumerable: false,
  configurable: true
});
var INTERNALS$2 = Symbol("Request internals");
var parse_url = import_url.default.parse;
var format_url = import_url.default.format;
var streamDestructionSupported = "destroy" in import_stream.default.Readable.prototype;
function isRequest(input) {
  return typeof input === "object" && typeof input[INTERNALS$2] === "object";
}
function isAbortSignal(signal) {
  const proto = signal && typeof signal === "object" && Object.getPrototypeOf(signal);
  return !!(proto && proto.constructor.name === "AbortSignal");
}
var Request = class {
  constructor(input) {
    let init = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    let parsedURL;
    if (!isRequest(input)) {
      if (input && input.href) {
        parsedURL = parse_url(input.href);
      } else {
        parsedURL = parse_url(`${input}`);
      }
      input = {};
    } else {
      parsedURL = parse_url(input.url);
    }
    let method = init.method || input.method || "GET";
    method = method.toUpperCase();
    if ((init.body != null || isRequest(input) && input.body !== null) && (method === "GET" || method === "HEAD")) {
      throw new TypeError("Request with GET/HEAD method cannot have body");
    }
    let inputBody = init.body != null ? init.body : isRequest(input) && input.body !== null ? clone(input) : null;
    Body.call(this, inputBody, {
      timeout: init.timeout || input.timeout || 0,
      size: init.size || input.size || 0
    });
    const headers = new Headers(init.headers || input.headers || {});
    if (inputBody != null && !headers.has("Content-Type")) {
      const contentType = extractContentType(inputBody);
      if (contentType) {
        headers.append("Content-Type", contentType);
      }
    }
    let signal = isRequest(input) ? input.signal : null;
    if ("signal" in init)
      signal = init.signal;
    if (signal != null && !isAbortSignal(signal)) {
      throw new TypeError("Expected signal to be an instanceof AbortSignal");
    }
    this[INTERNALS$2] = {
      method,
      redirect: init.redirect || input.redirect || "follow",
      headers,
      parsedURL,
      signal
    };
    this.follow = init.follow !== void 0 ? init.follow : input.follow !== void 0 ? input.follow : 20;
    this.compress = init.compress !== void 0 ? init.compress : input.compress !== void 0 ? input.compress : true;
    this.counter = init.counter || input.counter || 0;
    this.agent = init.agent || input.agent;
  }
  get method() {
    return this[INTERNALS$2].method;
  }
  get url() {
    return format_url(this[INTERNALS$2].parsedURL);
  }
  get headers() {
    return this[INTERNALS$2].headers;
  }
  get redirect() {
    return this[INTERNALS$2].redirect;
  }
  get signal() {
    return this[INTERNALS$2].signal;
  }
  clone() {
    return new Request(this);
  }
};
Body.mixIn(Request.prototype);
Object.defineProperty(Request.prototype, Symbol.toStringTag, {
  value: "Request",
  writable: false,
  enumerable: false,
  configurable: true
});
Object.defineProperties(Request.prototype, {
  method: {enumerable: true},
  url: {enumerable: true},
  headers: {enumerable: true},
  redirect: {enumerable: true},
  clone: {enumerable: true},
  signal: {enumerable: true}
});
function getNodeRequestOptions(request) {
  const parsedURL = request[INTERNALS$2].parsedURL;
  const headers = new Headers(request[INTERNALS$2].headers);
  if (!headers.has("Accept")) {
    headers.set("Accept", "*/*");
  }
  if (!parsedURL.protocol || !parsedURL.hostname) {
    throw new TypeError("Only absolute URLs are supported");
  }
  if (!/^https?:$/.test(parsedURL.protocol)) {
    throw new TypeError("Only HTTP(S) protocols are supported");
  }
  if (request.signal && request.body instanceof import_stream.default.Readable && !streamDestructionSupported) {
    throw new Error("Cancellation of streamed requests with AbortSignal is not supported in node < 8");
  }
  let contentLengthValue = null;
  if (request.body == null && /^(POST|PUT)$/i.test(request.method)) {
    contentLengthValue = "0";
  }
  if (request.body != null) {
    const totalBytes = getTotalBytes(request);
    if (typeof totalBytes === "number") {
      contentLengthValue = String(totalBytes);
    }
  }
  if (contentLengthValue) {
    headers.set("Content-Length", contentLengthValue);
  }
  if (!headers.has("User-Agent")) {
    headers.set("User-Agent", "node-fetch/1.0 (+https://github.com/bitinn/node-fetch)");
  }
  if (request.compress && !headers.has("Accept-Encoding")) {
    headers.set("Accept-Encoding", "gzip,deflate");
  }
  let agent2 = request.agent;
  if (typeof agent2 === "function") {
    agent2 = agent2(parsedURL);
  }
  if (!headers.has("Connection") && !agent2) {
    headers.set("Connection", "close");
  }
  return Object.assign({}, parsedURL, {
    method: request.method,
    headers: exportNodeCompatibleHeaders(headers),
    agent: agent2
  });
}
function AbortError(message) {
  Error.call(this, message);
  this.type = "aborted";
  this.message = message;
  Error.captureStackTrace(this, this.constructor);
}
AbortError.prototype = Object.create(Error.prototype);
AbortError.prototype.constructor = AbortError;
AbortError.prototype.name = "AbortError";
var PassThrough$1 = import_stream.default.PassThrough;
var resolve_url = import_url.default.resolve;
function fetch(url, opts) {
  if (!fetch.Promise) {
    throw new Error("native promise missing, set fetch.Promise to your favorite alternative");
  }
  Body.Promise = fetch.Promise;
  return new fetch.Promise(function(resolve, reject) {
    const request = new Request(url, opts);
    const options = getNodeRequestOptions(request);
    const send = (options.protocol === "https:" ? import_https.default : import_http.default).request;
    const signal = request.signal;
    let response = null;
    const abort = function abort2() {
      let error = new AbortError("The user aborted a request.");
      reject(error);
      if (request.body && request.body instanceof import_stream.default.Readable) {
        request.body.destroy(error);
      }
      if (!response || !response.body)
        return;
      response.body.emit("error", error);
    };
    if (signal && signal.aborted) {
      abort();
      return;
    }
    const abortAndFinalize = function abortAndFinalize2() {
      abort();
      finalize();
    };
    const req = send(options);
    let reqTimeout;
    if (signal) {
      signal.addEventListener("abort", abortAndFinalize);
    }
    function finalize() {
      req.abort();
      if (signal)
        signal.removeEventListener("abort", abortAndFinalize);
      clearTimeout(reqTimeout);
    }
    if (request.timeout) {
      req.once("socket", function(socket) {
        reqTimeout = setTimeout(function() {
          reject(new FetchError(`network timeout at: ${request.url}`, "request-timeout"));
          finalize();
        }, request.timeout);
      });
    }
    req.on("error", function(err) {
      reject(new FetchError(`request to ${request.url} failed, reason: ${err.message}`, "system", err));
      finalize();
    });
    req.on("response", function(res) {
      clearTimeout(reqTimeout);
      const headers = createHeadersLenient(res.headers);
      if (fetch.isRedirect(res.statusCode)) {
        const location = headers.get("Location");
        const locationURL = location === null ? null : resolve_url(request.url, location);
        switch (request.redirect) {
          case "error":
            reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, "no-redirect"));
            finalize();
            return;
          case "manual":
            if (locationURL !== null) {
              try {
                headers.set("Location", locationURL);
              } catch (err) {
                reject(err);
              }
            }
            break;
          case "follow":
            if (locationURL === null) {
              break;
            }
            if (request.counter >= request.follow) {
              reject(new FetchError(`maximum redirect reached at: ${request.url}`, "max-redirect"));
              finalize();
              return;
            }
            const requestOpts = {
              headers: new Headers(request.headers),
              follow: request.follow,
              counter: request.counter + 1,
              agent: request.agent,
              compress: request.compress,
              method: request.method,
              body: request.body,
              signal: request.signal,
              timeout: request.timeout,
              size: request.size
            };
            if (res.statusCode !== 303 && request.body && getTotalBytes(request) === null) {
              reject(new FetchError("Cannot follow redirect with body being a readable stream", "unsupported-redirect"));
              finalize();
              return;
            }
            if (res.statusCode === 303 || (res.statusCode === 301 || res.statusCode === 302) && request.method === "POST") {
              requestOpts.method = "GET";
              requestOpts.body = void 0;
              requestOpts.headers.delete("content-length");
            }
            resolve(fetch(new Request(locationURL, requestOpts)));
            finalize();
            return;
        }
      }
      res.once("end", function() {
        if (signal)
          signal.removeEventListener("abort", abortAndFinalize);
      });
      let body = res.pipe(new PassThrough$1());
      const response_options = {
        url: request.url,
        status: res.statusCode,
        statusText: res.statusMessage,
        headers,
        size: request.size,
        timeout: request.timeout,
        counter: request.counter
      };
      const codings = headers.get("Content-Encoding");
      if (!request.compress || request.method === "HEAD" || codings === null || res.statusCode === 204 || res.statusCode === 304) {
        response = new Response(body, response_options);
        resolve(response);
        return;
      }
      const zlibOptions = {
        flush: import_zlib.default.Z_SYNC_FLUSH,
        finishFlush: import_zlib.default.Z_SYNC_FLUSH
      };
      if (codings == "gzip" || codings == "x-gzip") {
        body = body.pipe(import_zlib.default.createGunzip(zlibOptions));
        response = new Response(body, response_options);
        resolve(response);
        return;
      }
      if (codings == "deflate" || codings == "x-deflate") {
        const raw = res.pipe(new PassThrough$1());
        raw.once("data", function(chunk) {
          if ((chunk[0] & 15) === 8) {
            body = body.pipe(import_zlib.default.createInflate());
          } else {
            body = body.pipe(import_zlib.default.createInflateRaw());
          }
          response = new Response(body, response_options);
          resolve(response);
        });
        return;
      }
      if (codings == "br" && typeof import_zlib.default.createBrotliDecompress === "function") {
        body = body.pipe(import_zlib.default.createBrotliDecompress());
        response = new Response(body, response_options);
        resolve(response);
        return;
      }
      response = new Response(body, response_options);
      resolve(response);
    });
    writeToStream(req, request);
  });
}
fetch.isRedirect = function(code) {
  return code === 301 || code === 302 || code === 303 || code === 307 || code === 308;
};
fetch.Promise = global.Promise;
var lib_default = fetch;

// src/downloader.ts
var zlib2 = __toModule(require("zlib"));
var import_path = __toModule(require("path"));
var import_stream2 = __toModule(require("stream"));
var import_util = __toModule(require("util"));
var pipeline = import_util.default.promisify(import_stream2.default.pipeline);
var agent = process.env.https_proxy ? new import_https_proxy_agent.HttpsProxyAgent(process.env.https_proxy) : null;
async function patchelf(dest) {
  const expression = `
{src, pkgs ? import <nixpkgs> {}}:
    pkgs.stdenv.mkDerivation {
        name = "rust-analyzer";
        inherit src;
        phases = [ "installPhase" "fixupPhase" ];
        installPhase = "cp $src $out";
        fixupPhase = ''
        chmod 755 $out
        patchelf --set-interpreter "$(cat $NIX_CC/nix-support/dynamic-linker)" $out
        '';
    }
`;
  const origFile = dest + "-orig";
  await import_fs.promises.rename(dest, origFile);
  await new Promise((resolve, reject) => {
    var _a, _b;
    const handle = import_child_process.exec(`nix-build -E - --arg src '${origFile}' -o ${dest}`, (err, stdout, stderr) => {
      if (err != null) {
        reject(Error(stderr));
      } else {
        resolve(stdout);
      }
    });
    (_a = handle.stdin) == null ? void 0 : _a.write(expression);
    (_b = handle.stdin) == null ? void 0 : _b.end();
  });
  await import_fs.promises.unlink(origFile);
}
function isMusl() {
  const res = import_child_process.spawnSync("ldd", ["--version"]);
  return res.stderr != null && res.stderr.indexOf("musl libc") >= 0;
}
function getPlatform() {
  const platforms = {
    "ia32 win32": "x86_64-pc-windows-msvc",
    "x64 win32": "x86_64-pc-windows-msvc",
    "x64 linux": "x86_64-unknown-linux-gnu",
    "x64 darwin": "x86_64-apple-darwin",
    "arm64 win32": "aarch64-pc-windows-msvc",
    "arm64 linux": "aarch64-unknown-linux-gnu",
    "arm64 darwin": "aarch64-apple-darwin"
  };
  let platform = platforms[`${process.arch} ${process.platform}`];
  if (platform === "x86_64-unknown-linux-gnu" && isMusl()) {
    platform = "x86_64-unknown-linux-musl";
  }
  return platform;
}
async function getLatestRelease(updatesChannel) {
  let releaseURL = "https://api.github.com/repos/rust-analyzer/rust-analyzer/releases/latest";
  if (updatesChannel === "nightly") {
    releaseURL = "https://api.github.com/repos/rust-analyzer/rust-analyzer/releases/tags/nightly";
  }
  const response = await lib_default(releaseURL, {agent});
  if (!response.ok) {
    console.error(await response.text());
    return;
  }
  const release = await response.json();
  const platform = getPlatform();
  if (!platform) {
    console.error(`Unfortunately we don't ship binaries for your platform yet.`);
    return;
  }
  const asset = release.assets.find((val) => val.browser_download_url.endsWith(`${platform}.gz`));
  if (!asset) {
    console.error(`getLatestRelease failed: ${release}`);
    return;
  }
  let tag = release.tag_name;
  if (updatesChannel === "nightly") {
    tag = `${release.tag_name} ${release.published_at.slice(0, 10)}`;
  }
  const name = process.platform === "win32" ? "rust-analyzer.exe" : "rust-analyzer";
  return {asset, tag, url: asset.browser_download_url, name};
}
async function downloadServer(context, release) {
  const statusItem = import_coc3.window.createStatusBarItem(0, {progress: true});
  statusItem.text = `Downloading rust-analyzer ${release.tag}`;
  statusItem.show();
  const resp = await lib_default(release.url, {agent});
  if (!resp.ok) {
    statusItem.hide();
    throw new Error("Download failed");
  }
  let cur = 0;
  const len = Number(resp.headers.get("content-length"));
  resp.body.on("data", (chunk) => {
    cur += chunk.length;
    const p = (cur / len * 100).toFixed(2);
    statusItem.text = `${p}% Downloading rust-analyzer ${release.tag}`;
  });
  const _path = import_path.default.join(context.storagePath, release.name);
  const randomHex = import_crypto.randomBytes(5).toString("hex");
  const tempFile = import_path.default.join(context.storagePath, `${release.name}${randomHex}`);
  const destFileStream = import_fs.createWriteStream(tempFile, {mode: 493});
  await pipeline(resp.body.pipe(zlib2.createGunzip()), destFileStream);
  await new Promise((resolve) => {
    destFileStream.on("close", resolve);
    destFileStream.destroy();
    setTimeout(resolve, 1e3);
  });
  await import_fs.promises.unlink(_path).catch((err) => {
    if (err.code !== "ENOENT")
      throw err;
  });
  await import_fs.promises.rename(tempFile, _path);
  await context.globalState.update("release", release.tag);
  try {
    if (await import_fs.promises.stat("/etc/nixos")) {
      statusItem.text = `Patching rust-analyzer executable...`;
      await patchelf(_path);
    }
  } catch (e) {
  }
  statusItem.hide();
}

// src/inlay_hints.ts
var import_coc4 = __toModule(require("coc.nvim"));
var import_vscode_languageserver_protocol2 = __toModule(require_main3());

// src/lsp_ext.ts
var lc = __toModule(require_main3());
var analyzerStatus = new lc.RequestType("rust-analyzer/analyzerStatus");
var memoryUsage = new lc.RequestType0("rust-analyzer/memoryUsage");
var status = new lc.NotificationType("rust-analyzer/status");
var reloadWorkspace = new lc.RequestType0("rust-analyzer/reloadWorkspace");
var syntaxTree = new lc.RequestType("rust-analyzer/syntaxTree");
var viewHir = new lc.RequestType("rust-analyzer/viewHir");
var expandMacro = new lc.RequestType("rust-analyzer/expandMacro");
var matchingBrace = new lc.RequestType("experimental/matchingBrace");
var parentModule = new lc.RequestType("experimental/parentModule");
var joinLines = new lc.RequestType("experimental/joinLines");
var onEnter = new lc.RequestType("experimental/onEnter");
var runnables = new lc.RequestType("experimental/runnables");
var InlayHint;
(function(InlayHint2) {
  let Kind;
  (function(Kind2) {
    Kind2["TypeHint"] = "TypeHint";
    Kind2["ParamHint"] = "ParameterHint";
    Kind2["ChainingHint"] = "ChainingHint";
  })(Kind = InlayHint2.Kind || (InlayHint2.Kind = {}));
})(InlayHint || (InlayHint = {}));
var inlayHints = new lc.RequestType("rust-analyzer/inlayHints");
var ssr = new lc.RequestType("experimental/ssr");
var openDocs = new lc.RequestType("experimental/externalDocs");
var openCargoToml = new lc.RequestType("experimental/openCargoToml");

// src/inlay_hints.ts
var HintsUpdater = class {
  constructor(ctx) {
    this.ctx = ctx;
    this.disposables = [];
    this.inlayHintsNS = import_coc4.workspace.createNameSpace("rust-inlay-hint");
    this.inlayHintsEnabled = !!this.ctx.config.inlayHints.enable;
  }
  dispose() {
    this.disposables.forEach((d) => d.dispose());
  }
  async activate() {
    import_coc4.events.on("InsertLeave", async (bufnr) => {
      const doc = import_coc4.workspace.getDocument(bufnr);
      if (doc && isRustDocument(doc.textDocument)) {
        doc.buffer.clearNamespace(this.inlayHintsNS);
        this.syncAndRenderHints(doc);
      }
    });
    import_coc4.workspace.onDidChangeTextDocument((e) => {
      const doc = import_coc4.workspace.getDocument(e.bufnr);
      if (doc && isRustDocument(doc.textDocument)) {
        doc.buffer.clearNamespace(this.inlayHintsNS);
        if (import_coc4.workspace.insertMode && !this.ctx.config.inlayHints.refreshOnInsertMode) {
          return;
        }
        this.syncAndRenderHints(doc);
      }
    }, this, this.disposables);
    import_coc4.workspace.onDidOpenTextDocument((e) => {
      if (e && isRustDocument(e)) {
        const doc = import_coc4.workspace.getDocument(e.uri);
        doc.buffer.clearNamespace(this.inlayHintsNS);
        this.syncAndRenderHints(doc);
      }
    }, this, this.disposables);
    const current = await import_coc4.workspace.document;
    if (isRustDocument(current.textDocument)) {
      current.buffer.clearNamespace(this.inlayHintsNS);
      this.syncAndRenderHints(current);
    }
  }
  async toggle() {
    if (this.inlayHintsEnabled) {
      this.inlayHintsEnabled = false;
      const doc = await import_coc4.workspace.document;
      if (!doc)
        return;
      doc.buffer.clearNamespace(this.inlayHintsNS);
    } else {
      this.inlayHintsEnabled = true;
      await this.activate();
    }
  }
  async syncAndRenderHints(doc) {
    if (!this.inlayHintsEnabled)
      return;
    if (doc && isRustDocument(doc.textDocument)) {
      const file = {document: doc.textDocument, inlaysRequest: null};
      this.fetchHints(file).then(async (hints) => {
        if (!hints)
          return;
        this.renderHints(doc, hints);
      });
    }
  }
  async renderHints(doc, hints) {
    console.error(hints);
    const decorations = {type: [], param: [], chaining: []};
    for (const hint of hints) {
      switch (hint.kind) {
        case InlayHint.Kind.TypeHint:
          decorations.type.push(hint);
          break;
        case InlayHint.Kind.ChainingHint:
          decorations.chaining.push(hint);
          break;
        default:
          continue;
      }
    }
    doc.buffer.clearNamespace(this.inlayHintsNS);
    const chaining_hints = {};
    const split = [" ", "Normal"];
    if (this.ctx.config.inlayHints.typeHints) {
      const sep = this.ctx.config.inlayHints.typeHintsSeparator;
      const showSymbol = this.ctx.config.inlayHints.typeHintsWithVariable;
      for (const item of decorations.type) {
        const sn_start = item.range.start.character;
        const sn_end = item.range.end.character;
        const line = doc.getline(item.range.start.line);
        const symbol_name = showSymbol ? `${line.substring(sn_start, sn_end)}: ` : "";
        const chunks = [[`${sep}${symbol_name}${item.label}`, "CocRustTypeHint"]];
        if (chaining_hints[item.range.end.line] === void 0) {
          chaining_hints[item.range.end.line] = chunks;
        } else {
          chaining_hints[item.range.end.line].push(split);
          chaining_hints[item.range.end.line].push(chunks[0]);
        }
        doc.buffer.setVirtualText(this.inlayHintsNS, item.range.end.line, chaining_hints[item.range.end.line], {});
      }
    }
    if (this.ctx.config.inlayHints.chainingHints) {
      const sep = this.ctx.config.inlayHints.chainingHintsSeparator;
      for (const item of decorations.chaining) {
        const chunks = [[`${sep}${item.label}`, "CocRustChainingHint"]];
        if (chaining_hints[item.range.end.line] === void 0) {
          chaining_hints[item.range.end.line] = chunks;
        } else {
          chaining_hints[item.range.end.line].push(split);
          chaining_hints[item.range.end.line].push(chunks[0]);
        }
        doc.buffer.setVirtualText(this.inlayHintsNS, item.range.end.line, chaining_hints[item.range.end.line], {});
      }
    }
  }
  async fetchHints(file) {
    var _a;
    (_a = file.inlaysRequest) == null ? void 0 : _a.cancel();
    const tokenSource = new import_vscode_languageserver_protocol2.CancellationTokenSource();
    file.inlaysRequest = tokenSource;
    const param = {textDocument: {uri: file.document.uri.toString()}};
    return this.ctx.sendRequestWithRetry(inlayHints, param, tokenSource.token).catch(() => null).finally(() => {
      if (file.inlaysRequest === tokenSource) {
        file.inlaysRequest = null;
      }
    });
  }
};

// src/ctx.ts
function isRustDocument(document2) {
  return document2.languageId === "rust";
}
var Ctx2 = class {
  constructor(extCtx) {
    this.extCtx = extCtx;
    this.config = new Config();
    this.sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
    this.statusBar = import_coc5.window.createStatusBarItem(10);
    this.statusBar.text = "rust-analyzer";
    this.extCtx.subscriptions.push(this.statusBar);
    this.updater = new HintsUpdater(this);
    this.extCtx.subscriptions.push(this.updater);
  }
  registerCommand(name, factory, internal = false) {
    const fullName = `rust-analyzer.${name}`;
    const cmd = factory(this);
    const d = import_coc5.commands.registerCommand(fullName, cmd, null, internal);
    this.extCtx.subscriptions.push(d);
  }
  async startServer() {
    const bin = this.resolveBin();
    if (!bin) {
      return;
    }
    const client = createClient(bin, this.config.serverExtraEnv);
    this.extCtx.subscriptions.push(import_coc5.services.registLanguageClient(client));
    const watcher = import_coc5.workspace.createFileSystemWatcher("**/Cargo.toml");
    this.extCtx.subscriptions.push(watcher);
    watcher.onDidChange(async () => await import_coc5.commands.executeCommand("rust-analyzer.reloadWorkspace"));
    await client.onReady();
    client.onNotification(status, async (params) => {
      const status2 = params.status;
      this.statusBar.text = `rust-analyzer ${status2}`;
      this.statusBar.show();
      if (status2 === "ready") {
        this.statusBar.hide();
      } else if (status2 === "needsReload") {
        const prompt = this.config.cargo.autoreload || await import_coc5.window.showPrompt(`rust-analyzer needs to reload project`);
        if (prompt) {
          await import_coc5.commands.executeCommand("rust-analyzer.reloadWorkspace");
          this.statusBar.hide();
        }
      }
    });
    this.client = client;
  }
  get subscriptions() {
    return this.extCtx.subscriptions;
  }
  resolveBin() {
    let bin = import_path2.join(this.extCtx.storagePath, process.platform === "win32" ? "rust-analyzer.exe" : "rust-analyzer");
    if (this.config.serverPath) {
      bin = this.config.serverPath;
      if (bin.startsWith("~/")) {
        bin = bin.replace("~", import_os.homedir());
      }
      bin = import_which.default.sync(bin, {nothrow: true}) || bin;
    }
    if (!import_fs2.existsSync(bin)) {
      return;
    }
    if (!import_executable.default.sync(bin)) {
      import_coc5.window.showMessage(`${bin} is not executable`, "error");
      return;
    }
    return bin;
  }
  async checkUpdate(auto = true) {
    if (this.config.serverPath) {
      return;
    }
    const latest = await getLatestRelease(this.config.channel);
    if (!latest) {
      return;
    }
    const old = this.extCtx.globalState.get("release") || "unknown release";
    if (old === latest.tag) {
      if (!auto) {
        import_coc5.window.showMessage(`Your Rust Analyzer release is updated`);
      }
      return;
    }
    const msg = `Rust Analyzer has a new release: ${latest.tag}, you're using ${old}. Would you like to download from GitHub`;
    let ret = 0;
    if (this.config.prompt) {
      ret = await import_coc5.window.showQuickpick(["Yes, download the latest rust-analyzer", "Check GitHub releases", "Cancel"], msg);
    }
    if (ret === 0) {
      if (process.platform === "win32") {
        await this.client.stop();
      }
      try {
        await downloadServer(this.extCtx, latest);
      } catch (e) {
        console.error(e);
        let msg2 = "Upgrade rust-analyzer failed, please try again";
        if (e.code === "EBUSY" || e.code === "ETXTBSY" || e.code === "EPERM") {
          msg2 = "Upgrade rust-analyzer failed, other Vim instances might be using it, you should close them and try again";
        }
        import_coc5.window.showMessage(msg2, "error");
        return;
      }
      await this.client.stop();
      this.client.start();
      this.extCtx.globalState.update("release", latest.tag);
    } else if (ret === 1) {
      await import_coc5.commands.executeCommand("vscode.open", "https://github.com/rust-analyzer/rust-analyzer/releases").catch(() => {
      });
    }
  }
  async sendRequestWithRetry(reqType, param, token) {
    for (const delay of [2, 4, 6, 8, 10, null]) {
      try {
        return await (token ? this.client.sendRequest(reqType, param, token) : this.client.sendRequest(reqType, param));
      } catch (error) {
        if (delay === null) {
          throw error;
        }
        if (error.code === import_vscode_languageserver_protocol3.ErrorCodes.RequestCancelled) {
          throw error;
        }
        if (error.code !== import_vscode_languageserver_protocol3.ErrorCodes.ContentModified) {
          throw error;
        }
        await this.sleep(10 * (1 << delay));
      }
    }
    throw "unreachable";
  }
  async activateInlayHints() {
    await import_coc5.workspace.nvim.command("hi default link CocRustChainingHint CocHintSign");
    await import_coc5.workspace.nvim.command("hi default link CocRustTypeHint CocHintSign");
    if (!this.config.inlayHints.enable) {
      return;
    }
    if (!this.config.inlayHints.chainingHints && !this.config.inlayHints.typeHints) {
      return;
    }
    this.updater.activate();
  }
  async toggleInlayHints() {
    await this.updater.toggle();
  }
};

// src/commands.ts
var terminal;
var RunnableQuickPick = class {
  constructor(runnable) {
    this.runnable = runnable;
    this.label = runnable.label;
  }
};
function isInRange(range, position) {
  const lineWithin = range.start.line <= position.line && range.end.line >= position.line;
  const charWithin = range.start.character <= position.character && range.end.line >= position.character;
  return lineWithin && charWithin;
}
function codeFormat(expanded) {
  let result = `// Recursive expansion of ${expanded.name}! macro
`;
  result += "// " + "=".repeat(result.length - 3);
  result += "\n\n";
  result += expanded.expansion;
  return result;
}
function parseSnippet(snip) {
  var _a;
  const m = snip.match(/\$(0|\{0:([^}]*)\})/);
  if (!m)
    return void 0;
  const placeholder = (_a = m[2]) != null ? _a : "";
  const range = [m.index, placeholder.length];
  const insert = snip.replace(m[0], placeholder);
  return [insert, range];
}
function countLines(text) {
  return (text.match(/\n/g) || []).length;
}
function analyzerStatus2(ctx) {
  return async () => {
    const {document: document2} = await import_coc6.workspace.getCurrentState();
    if (!isRustDocument(document2))
      return;
    const params = {
      textDocument: {uri: document2.uri}
    };
    const ret = await ctx.client.sendRequest(analyzerStatus, params);
    import_coc6.window.echoLines(ret.split("\n"));
  };
}
function memoryUsage2(ctx) {
  return async () => {
    const ret = await ctx.client.sendRequest(memoryUsage);
    import_coc6.window.echoLines(ret.split("\n"));
  };
}
function matchingBrace2(ctx) {
  return async () => {
    const {document: document2, position} = await import_coc6.workspace.getCurrentState();
    if (!isRustDocument(document2))
      return;
    const params = {
      textDocument: {uri: document2.uri},
      positions: [position]
    };
    const response = await ctx.client.sendRequest(matchingBrace, params);
    if (response.length > 0) {
      import_coc6.workspace.jumpTo(document2.uri, response[0]);
    }
  };
}
function joinLines2(ctx) {
  return async () => {
    const doc = await import_coc6.workspace.document;
    if (!isRustDocument(doc.textDocument))
      return;
    let range = null;
    const mode = await import_coc6.workspace.nvim.call("visualmode");
    if (mode) {
      range = await import_coc6.workspace.getSelectedRange(mode, doc);
    }
    if (!range) {
      const state = await import_coc6.workspace.getCurrentState();
      range = import_vscode_languageserver_protocol4.Range.create(state.position, state.position);
    }
    const param = {
      textDocument: {uri: doc.uri},
      ranges: [range]
    };
    const items = await ctx.client.sendRequest(joinLines, param);
    await doc.applyEdits(items);
  };
}
function parentModule2(ctx) {
  return async () => {
    var _a, _b;
    const {document: document2, position} = await import_coc6.workspace.getCurrentState();
    if (!isRustDocument(document2))
      return;
    const param = {
      textDocument: {uri: document2.uri},
      position
    };
    const response = await ctx.client.sendRequest(parentModule, param);
    if (!response)
      return;
    let uri = "";
    let pos = void 0;
    if (Array.isArray(response)) {
      const location = response[0];
      if (import_vscode_languageserver_protocol4.Location.is(location)) {
        uri = location.uri;
        pos = (_a = location.range) == null ? void 0 : _a.start;
      } else if (import_vscode_languageserver_protocol4.LocationLink.is(location)) {
        uri = location.targetUri;
        pos = (_b = location.targetSelectionRange) == null ? void 0 : _b.start;
      }
    } else if (import_vscode_languageserver_protocol4.Location.is(response)) {
      uri = response.uri;
      pos = response.range.start;
    }
    if (uri) {
      import_coc6.workspace.jumpTo(uri, pos);
    }
  };
}
function ssr2(ctx) {
  return async () => {
    const input = await import_coc6.workspace.callAsync("input", ["Enter request like this: foo($a, $b) ==>> ($a).foo($b): "]);
    import_coc6.workspace.nvim.command("normal! :<C-u>", true);
    if (!input) {
      return;
    }
    if (!input.includes("==>>")) {
      return;
    }
    const selections = [];
    const mode = await import_coc6.workspace.nvim.call("visualmode");
    if (mode) {
      const doc = await import_coc6.workspace.document;
      const range = await import_coc6.workspace.getSelectedRange(mode, doc);
      if (range)
        selections.push(range);
    }
    const {document: document2, position} = await import_coc6.workspace.getCurrentState();
    const param = {
      query: input,
      parseOnly: false,
      textDocument: {uri: document2.uri},
      position,
      selections
    };
    import_coc6.window.withProgress({title: "Structured search replacing...", cancellable: false}, () => {
      return new Promise(async (resolve) => {
        const edit = await ctx.client.sendRequest(ssr, param);
        await import_coc6.workspace.applyEdit(edit);
        resolve();
      });
    });
  };
}
function serverVersion(ctx) {
  return async () => {
    const bin = ctx.resolveBin();
    if (!bin) {
      const msg = `Rust Analyzer is not found`;
      import_coc6.window.showMessage(msg, "error");
      return;
    }
    const version = import_child_process2.spawnSync(bin, ["--version"], {encoding: "utf-8"}).stdout.toString();
    import_coc6.window.showMessage(version);
  };
}
async function fetchRunnable(ctx) {
  const {document: document2, position} = await import_coc6.workspace.getCurrentState();
  if (!isRustDocument(document2))
    return;
  import_coc6.window.showMessage(`Fetching runnable...`);
  const params = {
    textDocument: {uri: document2.uri},
    position
  };
  const runnables2 = await ctx.client.sendRequest(runnables, params);
  const items = [];
  for (const r of runnables2) {
    items.push(new RunnableQuickPick(r));
  }
  const idx = await import_coc6.window.showQuickpick(items.map((o) => o.label));
  if (idx === -1) {
    return;
  }
  return items[idx].runnable;
}
function run(ctx) {
  return async () => {
    const runnable = await fetchRunnable(ctx);
    if (!runnable)
      return;
    const cmd = `${runnable.kind} ${runnable.args.cargoArgs.join(" ")}`;
    const opt = {
      name: runnable.label,
      cwd: runnable.args.workspaceRoot
    };
    if (terminal) {
      terminal.dispose();
      terminal = void 0;
    }
    terminal = await import_coc6.workspace.createTerminal(opt);
    terminal.sendText(cmd);
    if (ctx.config.terminal.startinsert) {
      await import_coc6.workspace.nvim.command("startinsert");
    }
  };
}
function debugSingle(ctx) {
  return async (runnable) => {
    const {document: document2} = await import_coc6.workspace.getCurrentState();
    if (!runnable || !isRustDocument(document2))
      return;
    const args = [...runnable.args.cargoArgs];
    if (runnable.args.cargoExtraArgs.length > 0) {
      args.push(...runnable.args.cargoExtraArgs);
    }
    if (args[0] === "test") {
      args.push("--no-run");
    }
    args.push("--message-format=json");
    args.push("-q");
    if (runnable.args.executableArgs.length > 0) {
      args.push("--", ...runnable.args.executableArgs);
    }
    if (args[0] === "run") {
      args[0] = "build";
    }
    console.debug(`${runnable.kind} ${args}`);
    const proc = import_child_process2.spawn(runnable.kind, args, {shell: true});
    const rl = import_readline.default.createInterface({
      input: proc.stdout,
      crlfDelay: Infinity
    });
    let executable2 = null;
    for await (const line of rl) {
      if (!line) {
        continue;
      }
      let cargoMessage = {};
      try {
        cargoMessage = JSON.parse(line);
      } catch (e) {
        console.error(e);
        continue;
      }
      if (!cargoMessage) {
        console.debug(`Skipping cargo message: ${cargoMessage}`);
      }
      if (cargoMessage["reason"] !== "compiler-artifact") {
        console.debug(`Not artifact: ${cargoMessage["reason"]}`);
        continue;
      }
      if (!executable2 && cargoMessage["executable"]) {
        executable2 = cargoMessage["executable"];
      }
    }
    if (!executable2) {
      throw new Error("Could not find executable");
    }
    const executableArgs = runnable.args.executableArgs.join(" ");
    console.info(`Debugging executable: ${executable2} ${executableArgs}`);
    const runtime = ctx.config.debug.runtime;
    if (runtime === "termdebug") {
      await import_coc6.workspace.nvim.command(`TermdebugCommand ${executable2} ${executableArgs}`);
      return;
    }
    if (runtime === "vimspector") {
      const name = ctx.config.debug.vimspectorConfiguration.name;
      const configuration = {configuration: name, Executable: executable2, Args: executableArgs};
      await import_coc6.workspace.nvim.call("vimspector#LaunchWithSettings", configuration);
      return;
    }
    throw new Error(`Invalid debug runtime: ${runtime}`);
  };
}
function runSingle(ctx) {
  return async (runnable) => {
    const {document: document2} = await import_coc6.workspace.getCurrentState();
    if (!runnable || !isRustDocument(document2))
      return;
    const args = [...runnable.args.cargoArgs];
    if (runnable.args.cargoExtraArgs.length > 0) {
      args.push(...runnable.args.cargoExtraArgs);
    }
    if (runnable.args.executableArgs.length > 0) {
      args.push("--", ...runnable.args.executableArgs);
    }
    const cmd = `${runnable.kind} ${args.join(" ")}`;
    const opt = {
      name: runnable.label,
      cwd: runnable.args.workspaceRoot
    };
    if (terminal) {
      terminal.dispose();
      terminal = void 0;
    }
    terminal = await import_coc6.workspace.createTerminal(opt);
    terminal.sendText(cmd);
    if (ctx.config.terminal.startinsert) {
      await import_coc6.workspace.nvim.command("startinsert");
    }
  };
}
function syntaxTree2(ctx) {
  return async () => {
    const doc = await import_coc6.workspace.document;
    if (!isRustDocument(doc.textDocument))
      return;
    const mode = await import_coc6.workspace.nvim.call("visualmode");
    let range = null;
    if (mode) {
      range = await import_coc6.workspace.getSelectedRange(mode, doc);
    }
    const param = {
      textDocument: {uri: doc.uri},
      range
    };
    const ret = await ctx.client.sendRequest(syntaxTree, param);
    await import_coc6.workspace.nvim.command("tabnew").then(async () => {
      const buf = await import_coc6.workspace.nvim.buffer;
      buf.setLines(ret.split("\n"), {start: 0, end: -1});
    });
  };
}
function expandMacro2(ctx) {
  return async () => {
    const {document: document2, position} = await import_coc6.workspace.getCurrentState();
    if (!isRustDocument(document2))
      return;
    const param = {
      textDocument: {uri: document2.uri},
      position
    };
    const expanded = await ctx.client.sendRequest(expandMacro, param);
    if (!expanded) {
      return;
    }
    await import_coc6.workspace.nvim.command("tabnew").then(async () => {
      const buf = await import_coc6.workspace.nvim.buffer;
      buf.setLines(codeFormat(expanded).split("\n"), {start: 0, end: -1});
    });
  };
}
function explainError(ctx) {
  return async () => {
    var _a, _b;
    const {document: document2, position} = await import_coc6.workspace.getCurrentState();
    if (!isRustDocument(document2))
      return;
    const diagnostic = (_b = (_a = ctx.client.diagnostics) == null ? void 0 : _a.get(document2.uri)) == null ? void 0 : _b.find((diagnostic2) => isInRange(diagnostic2.range, position));
    if (diagnostic == null ? void 0 : diagnostic.code) {
      const explaination = import_child_process2.spawnSync("rustc", ["--explain", `${diagnostic.code}`], {encoding: "utf-8"}).stdout.toString();
      const docs = [];
      let isCode = false;
      for (const part of explaination.split("```\n")) {
        docs.push({content: part, filetype: isCode ? "rust" : "markdown"});
        isCode = !isCode;
      }
      const factory = new import_coc6.FloatFactory(import_coc6.workspace.nvim);
      await factory.show(docs);
    }
  };
}
function reloadWorkspace2(ctx) {
  return async () => {
    await ctx.client.sendRequest(reloadWorkspace);
  };
}
function showReferences() {
  return async (uri, position, locations) => {
    if (!uri) {
      return;
    }
    await import_coc6.commands.executeCommand("editor.action.showReferences", import_coc6.Uri.parse(uri), position, locations);
  };
}
function upgrade(ctx) {
  return async () => {
    await ctx.checkUpdate(false);
  };
}
function toggleInlayHints(ctx) {
  return async () => {
    if (!ctx.config.inlayHints.chainingHints) {
      import_coc6.window.showMessage(`Inlay hints for method chains is disabled. Toggle action does nothing;`, "warning");
      return;
    }
    await ctx.toggleInlayHints();
  };
}
async function applySnippetWorkspaceEdit(edit) {
  var _a;
  if (!((_a = edit == null ? void 0 : edit.documentChanges) == null ? void 0 : _a.length)) {
    return;
  }
  let selection = void 0;
  let position = void 0;
  let lineDelta = 0;
  const change = edit.documentChanges[0];
  if (import_vscode_languageserver_protocol4.TextDocumentEdit.is(change)) {
    const newEdits = [];
    for (const indel of change.edits) {
      let {newText} = indel;
      const parsed = parseSnippet(indel.newText);
      if (parsed) {
        const [insert, [placeholderStart, placeholderLength]] = parsed;
        const prefix = insert.substr(0, placeholderStart);
        const lastNewline = prefix.lastIndexOf("\n");
        const startLine = indel.range.start.line + lineDelta + countLines(prefix);
        const startColumn = lastNewline === -1 ? indel.range.start.character + placeholderStart : prefix.length - lastNewline - 1;
        if (placeholderLength) {
          selection = import_vscode_languageserver_protocol4.Range.create(startLine, startColumn, startLine, startColumn + placeholderLength);
        } else {
          position = import_vscode_languageserver_protocol4.Position.create(startLine, startColumn);
        }
        newText = insert;
      } else {
        lineDelta = countLines(indel.newText) - (indel.range.end.line - indel.range.start.line);
      }
      newEdits.push(import_vscode_languageserver_protocol4.TextEdit.replace(indel.range, newText));
    }
    const current = await import_coc6.workspace.document;
    if (current.uri !== change.textDocument.uri) {
      await import_coc6.workspace.loadFile(change.textDocument.uri);
      await import_coc6.workspace.jumpTo(change.textDocument.uri);
    }
    const wsEdit = {
      changes: {
        [change.textDocument.uri]: newEdits
      }
    };
    await import_coc6.workspace.applyEdit(wsEdit);
    if (selection) {
      await import_coc6.workspace.selectRange(selection);
    } else if (position) {
      await import_coc6.window.moveTo(position);
    }
  }
}
function applySnippetWorkspaceEditCommand() {
  return async (edit) => {
    await applySnippetWorkspaceEdit(edit);
  };
}
function resolveCodeAction(ctx) {
  return async (params) => {
    var _a;
    const item = await ctx.client.sendRequest("codeAction/resolve", params);
    if (!(item == null ? void 0 : item.edit))
      return;
    const wsEditWithoutTextEdits = {
      documentChanges: (_a = item.edit.documentChanges) == null ? void 0 : _a.filter((change) => "kind" in change)
    };
    await import_coc6.workspace.applyEdit(wsEditWithoutTextEdits);
    await applySnippetWorkspaceEdit(item.edit);
  };
}
function openDocs2(ctx) {
  return async () => {
    const {document: document2, position} = await import_coc6.workspace.getCurrentState();
    if (!isRustDocument(document2))
      return;
    const param = {
      textDocument: {uri: document2.uri},
      position
    };
    const doclink = await ctx.client.sendRequest(openDocs, param);
    if (doclink) {
      await import_coc6.commands.executeCommand("vscode.open", import_coc6.Uri.parse(doclink));
    }
  };
}
function openCargoToml2(ctx) {
  return async () => {
    const {document: document2} = await import_coc6.workspace.getCurrentState();
    if (!isRustDocument(document2))
      return;
    const location = await ctx.client.sendRequest(openCargoToml, {
      textDocument: {uri: document2.uri}
    });
    if (!location)
      return;
    await import_coc6.workspace.jumpTo(location.uri);
  };
}
function viewHir2(ctx) {
  return async () => {
    const {document: document2, position} = await import_coc6.workspace.getCurrentState();
    if (!isRustDocument(document2))
      return;
    const param = {
      textDocument: {uri: document2.uri},
      position
    };
    const ret = await ctx.client.sendRequest(viewHir, param);
    await import_coc6.workspace.nvim.command("tabnew").then(async () => {
      const buf = await import_coc6.workspace.nvim.buffer;
      buf.setLines(ret.split("\n"), {start: 0, end: -1});
    });
  };
}
function echoRunCommandLine(ctx) {
  return async () => {
    const runnable = await fetchRunnable(ctx);
    if (!runnable)
      return;
    const args = [...runnable.args.cargoArgs];
    if (runnable.args.cargoExtraArgs) {
      args.push(...runnable.args.cargoExtraArgs);
    }
    if (runnable.args.executableArgs.length > 0) {
      args.push("--", ...runnable.args.executableArgs);
    }
    const commandLine = ["cargo", ...args].join(" ");
    import_coc6.window.showMessage(commandLine);
  };
}

// src/index.ts
async function activate(context) {
  const ctx = new Ctx2(context);
  if (!ctx.config.enable) {
    return;
  }
  const serverRoot = context.storagePath;
  if (!import_fs3.existsSync(serverRoot)) {
    import_fs3.mkdirSync(serverRoot);
  }
  const bin = ctx.resolveBin();
  if (!bin) {
    let msg = "Rust Analyzer is not found, download from GitHub release?";
    let ret = 0;
    if (ctx.config.prompt) {
      ret = await import_coc7.window.showQuickpick(["Yes", "Cancel"], msg);
    }
    if (ret === 0) {
      try {
        const latest = await getLatestRelease(ctx.config.channel);
        if (!latest)
          throw new Error("Failed to get latest release");
        await downloadServer(context, latest);
      } catch (e) {
        console.error(e);
        msg = "Download rust-analyzer failed, you can get it from https://github.com/rust-analyzer/rust-analyzer";
        import_coc7.window.showMessage(msg, "error");
        return;
      }
    } else {
      return;
    }
  }
  ctx.registerCommand("runSingle", runSingle, true);
  ctx.registerCommand("debugSingle", debugSingle, true);
  ctx.registerCommand("showReferences", showReferences, true);
  ctx.registerCommand("resolveCodeAction", resolveCodeAction, true);
  ctx.registerCommand("applySnippetWorkspaceEdit", applySnippetWorkspaceEditCommand, true);
  ctx.registerCommand("run", run);
  ctx.registerCommand("ssr", ssr2);
  ctx.registerCommand("upgrade", upgrade);
  ctx.registerCommand("viewHir", viewHir2);
  ctx.registerCommand("openDocs", openDocs2);
  ctx.registerCommand("joinLines", joinLines2);
  ctx.registerCommand("syntaxTree", syntaxTree2);
  ctx.registerCommand("memoryUsage", memoryUsage2);
  ctx.registerCommand("expandMacro", expandMacro2);
  ctx.registerCommand("explainError", explainError);
  ctx.registerCommand("parentModule", parentModule2);
  ctx.registerCommand("matchingBrace", matchingBrace2);
  ctx.registerCommand("openCargoToml", openCargoToml2);
  ctx.registerCommand("serverVersion", serverVersion);
  ctx.registerCommand("analyzerStatus", analyzerStatus2);
  ctx.registerCommand("reloadWorkspace", reloadWorkspace2);
  ctx.registerCommand("toggleInlayHints", toggleInlayHints);
  ctx.registerCommand("echoRunCommandLine", echoRunCommandLine);
  ctx.registerCommand("reload", (ctx2) => {
    return async () => {
      import_coc7.window.showMessage(`Reloading rust-analyzer...`);
      for (const sub of ctx2.subscriptions) {
        try {
          sub.dispose();
        } catch (e) {
          console.error(e);
        }
      }
      await activate(context);
      import_coc7.window.showMessage(`Reloaded rust-analyzer`);
    };
  });
  await ctx.startServer();
  await ctx.activateInlayHints();
  if (bin)
    await ctx.checkUpdate();
}
